# 11.30从实现层面看矩阵转换

上次我们理解了矩阵转换的原理，思考了如何通过矩阵乘法把一个向量从原本坐标系转换成世界坐标系，再到相机的视角，今天来看看在glm数学库中，这些矩阵是怎么实现的，又该如何表示我们的公式：

局部坐标 -> model -> view -> projection -> 最终坐标数据



## 先说结论：

model 模型矩阵会是一个 **平移 (Translate)**、**旋转 (Rotate)** 和 **缩放 (Scale)** 的组合，

view 观察矩阵会是一个 **glm::translate+glm::rotate 或 glm::lookAt** 类型的， 

projection 投影矩阵会是一个 glm::正交或投影（即 **glm::ortho 或 glm::perspective**）

那么，这些构造矩阵的函数是什么意思？又是如何工作的？

## 1. Model Matrix (模型矩阵)

 Model 矩阵通常是 **平移 (Translate)**、**旋转 (Rotate)** 和 **缩放 (Scale)** 的组合

#### 1.glm::translate(**matrix, vector**)

translate所实现的是**平移**，接收参数是一个矩阵和一个向量

| 1       0       0       0    |      |      |      |
| ---------------------------- | ---- | ---- | ---- |
| 0        1        0        0 |      |      |      |
| 0        0        1        0 |      |      |      |
| 0        0        0        1 |      |      |      |

一般把这个单位矩阵作为参数传入matrix，

（x,  y,  z）作为向量参数传入vector，

内部原理matrix * vec4(vector, 1)，结果就是：

| 1       0       0       x    |      |      |      |
| ---------------------------- | ---- | ---- | ---- |
| 0        1        0        y |      |      |      |
| 0        0        1        z |      |      |      |
| 0        0        0        1 |      |      |      |

这个矩阵乘以一个新的顶点 (vx,vy,vz,1)时，根据矩阵乘法规则，结果就是 (vx+**x**,vy+**y**,vz+**z**,1)，实现了平移

可见这个矩阵乘以任何其它向量或坐标都会让结果平移**（x,  y,  z）**。

## 2. View Matrix (观察矩阵)

**核心任务**：模拟摄像机。
**本质逻辑**：OpenGL 里没有真正的摄像机。**把相机向后移动 = 把整个世界向前移动**。View 矩阵就是在这个逆向思维下产生的变换矩阵。

### 1. `glm::lookAt` 的参数与原理



函数原型通常是这样的：

```
glm::mat4 view = glm::lookAt(glm::vec3 eye, glm::vec3 center, glm::vec3 up);
```

- **eye (相机位置)**: 很简单，相机在世界哪里。
- **center (目标点)**: 相机看哪里。
- **up (上向量)**: **这是最关键也是最容易让人困惑的参数。** 我们待会儿重点展开。

#### 它的数学原理（造轴三部曲）

要构建一个 3D 坐标系，我们需要三个互相垂直的轴（Right, Up, Forward），也就是相机的局部 X, Y, Z 轴。`lookAt` 通过以下步骤“制造”出这三个轴：

**第一步：确定 Z 轴（Forward / Direction）**

既然知道了相机在哪 (eye)，也知道了看哪 (center)，那这两个点的连线就是视线方向。

- *注意*：在 OpenGL 中，相机默认看向 **-Z** 方向。所以，**+Z** 轴其实是从目标指向相机的方向（**指向相机的坐标**）。

  

  
  $$
  Zaxis = (eye - center)
  $$



**第二步：确定 X 轴（Right）**

现在我们有了一根轴（Z轴），我们需要第二根轴（X轴）。X轴应该垂直于 Z 轴。

这里用到了叉乘（Cross Product）：两个向量叉乘，会得到一个同时垂直于这两个向量的新向量。

这时候，参数 up 登场了！

**up是给定的！一般就是世界空间的  y轴  正方向的  单位向量！


$$
Xaxis = cross(up, Zaxis)
$$


**第三步：确定 Y 轴（True Camera Up）**

现在有了 Z 轴和 X 轴，它们绝对垂直。虽然我们传入了一个 up 向量，但那个 up 只是一个“参考的大概方向”（通常是世界的正上方），它可能并不垂直于 Z 轴。

我们需要算出一个真正的、垂直于 X 和 Z 的相机 Y 轴。


$$
Yaxis = cross(Zaxis, Xaxis)
$$

------



### 2. 深度解析：为什么 `up` 向量取世界空间的y轴正方向？



**想象一下你就是一个相机：**

1. 我让你站在房间角落（Eye），看着桌上的苹果（Center）。
2. 你可以**直立**着看苹果。
3. 你可以**歪着头**看苹果。
4. 你可以**倒立**着看苹果。

在所有这些动作中，`Eye` 和 `Center` 都没有变，视线（Z轴）也没变。但是，你的**视野画面**变了（旋转了），这其实就是我们的**X轴和Y轴在旋转**。

**up 向量的作用就是锁死这个旋转自由度。** 它告诉数学库：“在所有可能的姿势中，请选择那个**头顶大致指向 up 方向**的姿势。”

- **默认情况 (0, 1, 0)**：这是说“相机的头顶应该朝向天空”。这是绝大多数第一人称游戏和编辑器视角的设定。
- **倒立 (0, -1, 0)**：相机的画面会上下颠倒。
- **侧躺 (1, 0, 0)**：相机的画面会旋转90度，像你躺在床上看东西一样。

> ⚠️ 必须注意的“万向节死锁”隐患：
>
> 如果你的视线方向（Eye 到 Center）和你的 up 向量平行（比如你站在赤道上，抬头正视正上方的太阳），叉乘 cross(up, Zaxis) 会得到 0 向量。
>
> 这会导致数学崩溃（无法确定 X 轴）。
>
> 现象：当你在游戏中抬头看正天顶或低头看正脚底时，视角有时会乱晃或失效，通常就是因为视线向量和世界 up 向量重合了。

------



### 3. 从实现层面看：view矩阵长什么样？



一旦算出了 R (Right/X), U (相机的 Up/Y 并非世界up), D (Direction/Z) 这三个向量，`glm::lookAt` 就会把它们填入一个矩阵。

View 矩阵的本质是：**平移整个世界，让相机回到原点；然后旋转整个世界，让世界对齐相机的朝向。**

所以 View 矩阵 = **[旋转矩阵]** * **[平移矩阵]**

![屏幕截图 2025-11-30 200955](images\屏幕截图 2025-11-30 200955.png)

##### 左边的矩阵是怎么来的？

首先我知道如何将一个向量转换到新的坐标系中：**点积**

比如向量（x,  y,  z）转置到坐标系（R,  U,  D）中，R/U/D就是三个基向量，分别对应x/y/z轴。

那么转换公式是：


$$
x' = x·R；y' = y·U；z' = z·D
$$


现在我们要考虑的是怎么把这个过程变成矩阵的乘法

![屏幕截图 2025-11-30 202517](images\屏幕截图 2025-11-30 202517.png)

## 3.Projection Matrix（glm::perspective 的参数）

`glm::perspective` 的参数决定了“镜头参数”。

```
glm::perspective(fov, aspect, near, far)
```

1. **fov (Field of View)**:
   - 这是**视野角度**（通常指垂直方向）。
   - **实现原理**：它决定了投影平面的高度。
   - $FOV$ 越大（如 90 度），能看到的东西越多，画面会有广角畸变（鱼眼效果）。
   - $FOV$ 越小（如 30 度），视野越窄，类似于长焦镜头（望远镜效果）。
2. **aspect (宽高比)**:
   - 通常是 `屏幕宽度 / 屏幕高度`。
   - **实现原理**：它修正 X 轴的缩放。如果不设置正确，你的正方形在宽屏显示器上会被拉伸成扁的长方形。
3. **near / far (近平面 / 远平面)**:
   - 定义了可视距离的范围。
   - **实现原理**：投影矩阵会把 Z 轴坐标映射到 $[-1, 1]$ (OpenGL 标准) 或 $[0, 1]$ 之间。
   - **坑**：`near` 不能设置为 0（会导致除以零错误），也不能设置得太小（会导致 Z-fighting 闪烁问题）；`far` 设置太大也会导致精度下降（远处的物体前后遮挡关系算不准）。