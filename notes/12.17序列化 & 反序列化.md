# 12.17序列化 & 反序列化

## 一、序列化

序列化是指，把程序运行时的数据（相机、实体等）通过某种规范，变成文本信息或二进制信息，从而实现保存。

我们使用的库是yaml-cpp，序列化的过程其实并不难，但是比较繁琐，大体结构：

```
// --- 序列化 XXX ---
out << YAML::Key << "XXX";
out << YAML::BeginMap;

// 获取XXX对象
out << YAML::Key << "XXX.属性1" << YAML::Value << XXX.a1;
// ...

out << YAML::EndMap; // XXX 结束
```

而我们就要层层递归这种结构，来构建整个场景。

这之中，又要对应地设置所有需要序列化对象的属性的get方法，所以很麻烦。

## 二、反序列化

类似的原理

```
auto XXXNode = data["XXX"];
if (XXXNode) {
	if (XXXNode["XXX.属性1"])
		XXXNode["XXX.属性1"].as<属性的类型>();
}
```

就能获取到每个属性的数据，只不过有时需要对数据进行额外的处理，并且最终要使用这些属性重新创建场景（创建Model并创建对应的实体和组件）。

### 值得一提

反序列化中值得一提的是对于Model的缓存，对于类型、资源（可以包括shader、模型.obj、纹理.png等等）都完全相同的model组件，我们只创建一次，但是通过创建一个model缓存，可以调用出来之前创建过的model进行实体的创建，也就是说实体还是那么多，但是可能会有很多实体指向同一个model对象。

这能为我们以后进行的实例化渲染优化，提供数据基础

（想象如果反序列化仍然是有多少实体创建多少model，那么实例化根本就没有效果）

（实例化渲染就是把相同的model但有不同transform等数据的物体集成在同一次DrawCall中，节省CPU和GPU的通信成本）