# 12.3重构shader和创建shaderLibrary

## 一、重构shader

之前依据cherno的OpenGL系列，对shader进行过抽象，于是一开始我便把代码搬到了引擎项目Snail里。

之前的代码主要是通过构造方法读取一个文件路径，然后按行读取字符串，在进行shader类型的判断和内容提取，编译部分大差不差，与cherno游戏引擎系列的抽象方法差别有2：

1.读文件的方法，游戏引擎系列使用了二进制读取

2.处理单shader内着色器代码段，游戏引擎系列支持了多段的读取，而OpenGL系列默认是vertex和fragment两部分

## 二、创建shaderLibrary

首先需要知道什么是shader library，回忆我们之前在ExampleLayer中使用shader的方式：首先持有一个成员m_Shader，然后传入并处理shader文件，最后bind & 传递uniforms进行使用；

shader library可以做到维护一个<shaderName, shaderLocation>的映射表，只要使用类似于**ShaderLibrary::Get("cube_shader")**，即可获取对应的shader，无需再持有成员或进行初始化和编译，实际上提供了将用户端Example的操作转移到Snail内部的能力，在之后可以创建很多默认的shader例如meshshader、skyshder等等，外部之间使用即可。

ShaderLibrary也比较简单：

```
class ShaderLibrary {
public:
    void Add(const Refptr<Shader>& shader);

    Refptr<Shader> Load(const std::string& filePath);
    Refptr<Shader> Load(const std::string& customName, const std::string& filePath);

    Refptr<Shader> Get(const std::string& name);
private:
    std::unordered_map<std::string, Refptr<Shader>> m_Shaders;

};
```

添加只需Add，加载并添加是Load，获取是Get。



**思考：**当然至此肯定还不是很完善，因为我们可以发现最后bind & 传递uniforms的步骤还是要进行的，这或许就涉及到材质系统了，我们后期可能会把shader与uniform数据进一步联系起来，再联合纹理等部分组成更高层的材质类。

