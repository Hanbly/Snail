# 11.19对于窗口事件的难点理解

> 1.关于OnEvent函数的问题：

**1.~~~OnEvent是什么东西？**

OnEvent的目的是在窗口事件发生时，能够接收一个窗口事件对象的引用，并进行对应处理。

**2.~~~为什么要把它进行绑定，而不直接作为SetEventCallback的参数进行赋值？**

因为函数签名不匹配：OnEvent定义在Application内部，属于一个非静态成员函数，函数签名实际上是void(Application*, Event&)，而SetEventCallback的签名是void(Event&)，二者不匹配，需要bind函数或Lambda方法进行适配。

![img](images\屏幕截图 2025-11-19 223450.png)

**3.~~~为什么把绑定后的返回值作为SetEventCallback的参数？如果只要调用OnEvent，为什么非要赋值给Windowswindow的data，直接调用OnEvent不可以吗？**

目的是:**解耦**。如果想直接调用OnEvent，那么：WindowsWindow 必须知道 Application 的存在：这意味着 WindowsWindow.h 文件里必须 #include "Application.h"。
WindowsWindow 必须持有 Application 的引用：WindowsWindow 对象需要一个指针或引用，指向一个Application 实例。它的构造函数可能会变成这样：WindowsWindow(const WindowProps& props, Application* app)

解决方法就是在WindowsWindow**维护一个函数指针**，它可以保存事件回调方法，也就是当**事件发生时**所要执行的函数，这时WindowsWindow只需要通过**访问其自身!内部!的一个数据**即可，而不是去调用Application的成员函数

**可复用性**：现在你可以把你的 Window 模块拿到一个完全不同的项目中去使用，因为它对外部的应用逻辑没有任何依赖。

**灵活性（“插件”模型）**：Application 可以在运行时决定当事件发生时，具体执行什么逻辑。它把自己的行为“插”进了 Window 提供的“插槽”里。

**4.~~~绑定函数bind的参数到底什么意思？**

见下方代码块

```
inline void SetEventCallback
(const EventCallbackFn& eventCallbackFn) override 
{
	m_Data.eventCallbackFn = eventCallbackFn;
}
```

```
m_AppWindow->SetEventCallback
(std::bind(
&Application::OnEvent, 		// 取需要绑定的函数指针
this, 				  		// 成员函数的对象指针
std::placeholders::_1));	// 占位符，_1 的意思								   是：“我现在不提供这个								   参数，但是将来调用我创								 建的这个新函数对象时，请								把调用者提供的第一个参数							   放在这里。”
```

所以，std::bind(&Application::OnEvent, this, std::placeholders::_1) 这行代码的整体含义是：

“创建一个新的、可调用的**对象**，这个对象包含**一个成员函数OnEvent**和**一个对象指针 this**当这个对象被调用并传入**一个参数**时，它实际上会执行 **this->OnEvent(传入的那个参数)**。”

而这个调用的方法原本可以定义为：

using Fn = std::bind(&Application::OnEvent,this,std::placeholders::_1);

使用**Fn(传入一个参数)**即可

```
m_AppWindow->SetEventCallback
```

是为了把这个可调用对象绑定到窗口数据m_Data中的EventCallbackFn eventCallbackFn，所以之后要使用：

data.eventCallbackFn(传入一个事件类型参数)

效果是调用OnEvent函数

> 2.关于WindowsWindow类data中的回调函数指针eventCallbackFn的使用问题：

1.~~~        // 1.传入的m_Window有什么用2.为什么*(WindowData*)可以而(WindowData&)不行3.Lambda的参数从哪里来4.data为什么通过glfw获取而不是用m_Window5.WindowResizeEvent event()的初始化为什么这样，而不是用new6.data.props.width是怎么操作到窗口对象实际的数据的7.为什么将窗口的大小数据更新写在设置事件参数之前8.多个类似的事件共享同一个窗口数据m_Data不会出问题吗，为什么同一个m_Data能反复传入不同的事件参数，这样做又有什么意义

> 3.std::bind()的进一步理解：

我的疑惑是SetEventCallback把这个函数对象绑定到数据上，之后的调用很直观：data.EventCallback(e)就是在调用并传参e；而Dispatch<WindowCloseEvent>(std::bind())之后并没有传入任何参数。

实际这是一个误区，因为Dispatch内部直接调用了其自身接受的那个参数（一个函数对象）:

![屏幕截图 2025-11-20 115800](images\屏幕截图 2025-11-20 115800.png)

m_Event就是占位符被传入的参数。

> 4.关于构造函数和类型转换的C++误区：

1.构造函数的调用被误解为函数声明：

- **核心问题**：这也是 **"Most Vexing Parse"** 的一种表现形式，专门针对默认构造函数。
- **编译器行为**：编译器将 WindowFocusEvent event(); 错误地解析为一个**函数声明**，而不是一个变量定义。它声明了一个名为 event 的函数，该函数不接受任何参数，并返回 WindowFocusEvent 类型。
- **导致错误**：与问题1相同，后续代码尝试将这个被误解为**函数**的 event 传递给期望**对象引用**的参数，导致类型不匹配。
- **解决方案与建议**：
  1. **移除空括号**: WindowFocusEvent event; 这是调用默认构造函数的正确传统语法。
  2. **使用花括号初始化**: WindowFocusEvent event{}; 这是现代 C++ 推荐的方式，可以完全避免此类歧义。

2.类型转换float(posx)被误解为函数声明中的参数定义：

- **核心问题**：该语法触发了 C++ 的 **"Most Vexing Parse"**（最令人烦恼的解析）规则。
- **编译器行为**：编译器将 MouseMoveEvent event(float(posx), float(posy)); 错误地解析为一个**函数声明**，而不是一个变量定义。它声明了一个名为 event 的函数，该函数返回 MouseMoveEvent 类型，并接受两个 float 类型的参数。
- **导致错误**：由于 event 被当作一个函数，在下一行 data.eventCallbackFn(event) 中，你试图将一个**函数**传递给一个期望**对象引用**的参数，导致类型不匹配，编译失败。
- **解决方案与建议**：
  1. **使用 static_cast**: MouseMoveEvent event(static_cast<float>(xpos), static_cast<float>(ypos)); 这种写法无歧义，是现代 C++ 的最佳实践。
  2. **使用花括号初始化**: MouseMoveEvent event{static_cast<float>(xpos), static_cast<float>(ypos)}; 同样无歧义，并且风格更统一。

> 5.调试程序有问题记得首先清理项目重新生成一下：

新传入了一些GLFW的回调函数之后，怎么运行都没反应，结果是没清理编译文件，vs没有重新编译，一直在运行之前的程序。