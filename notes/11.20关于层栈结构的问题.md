# 11.20关于层栈结构的问题

> 1.什么是层栈结构？

用于管理和组织应用程序的不同功能模块（即“层”）

比如：

最底层：可能是游戏世界的背景。
中间层：是游戏角色和物体。
再上一层：是用户界面（UI），比如生命条、得分。
最顶层：可能是一个暂停菜单或者调试信息（Debug Overlay）。

按cherno的说法，层是按照从底到上的顺序依次渲染的，先画背景，再画角色，最后画UI，这样可以确保UI总是在游戏世界的上面；而事件通常是从上到下传递的，如果最顶层UI可见，那么它会首先接收到用户输入，同时处理事件，这时下方的层（游戏世界层）就不会再收到这个输入事件。

> 2.怎么理解m_LayerInsert？

它是一个迭代器，指向普通层和覆盖层的分界线，所有新添加的 PushLayer 会被插入到这个迭代器指向的位置。

从实际内存来看，他指向**普通层的**最后一个元素的下一个位置=**覆盖层的**首个元素的位置。

可以作为参数和边界条件。

> 3.为什么使用Layer*作为类型？

最重要的一点是支持多态：Layer不是一个实体类，而是基类，它的作用是向其它派生类提供一些通用的函数声明和属性。如果直接存储 Layer 对象 (std::vector<Layer>)，当试图把一个派生类对象（如 ImGuiLayer）放进去时，会发生**对象切片 (Object Slicing)**。这意味着派生类中特有的数据和行为会全部丢失，它会被“切”成一个纯粹的 Layer 基类对象；相反使用Layer\*可以很好的存储任何派生类，Layer\*既可以指向一个Layer也可以指向任何派生类对象。

> 4.我认为Cherno的P13节实现有问题

依据他的视频，LayerStack的结构应当是这样的：

普通1	普通2	普通3	覆盖1	覆盖2	覆盖3

​											  ↑

​										   input

普通push覆盖push各三次，普通每次在input之前插入一个层，覆盖每次在尾部插入一个层；弹出层的时候，我认为应当在各自层范围内进行find()并弹出，例如：

```
void LayerStack::PopNorLayer(Layer* norLayer)
{
	auto it = std::find(m_Layers.begin(), m_InsertPointer, norLayer);
	// it迭代器在普通层的范围内
	if (it < m_InsertPointer) {
		m_Layers.erase(it);
		m_InsertPointer--;
	}
	else {
		SNL_CORE_WARN("LayerStack warning: 弹出普通层失败: 超出层栈边界!");
	}
}
```

我不理解cherno为什么从begin查找到end，而且判断条件只有it!=end()（应该约等于it<end()，迭代器在end之前找到了某层），这样根本无法实现在某种层中弹出一个特定的层，反而很有可能弹出另一个种类的层级。

附上cherno的实现：

![屏幕截图 2025-11-20 230816](images\屏幕截图 2025-11-20 230816.png)