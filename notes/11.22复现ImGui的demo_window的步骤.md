# 11.22复现ImGui的demo_window的步骤

首先ImGui是一个支持各种图形库和平台的ui库，可以方便地显示在各种方式创建的窗口之上，并提供UI交互功能。

> 1.ImGui配置

我首先去GitHub上fork整个imgui项目，我的库：

https://github.com/Hanbly/imgui/tree/docking

然后把其中的docking分支作为子项目导入，这个分支能让各个ui窗口脱离原窗口，可以提供附着布局。

整个项目包含许多不同版本的使用示例，以及基本所有使用的方法，这些东西包含在：

![屏幕截图 2025-11-22 111536](images\屏幕截图 2025-11-22 111536.png)

其中examples便是使用的方法，而backends包括使用时所有所需要的.h和.cpp文件，具体操作如下：

针对glfw和opengl3，直接复制backends下的如下文件，放入Snail\ImGui\Platform\OpenGL

![屏幕截图 2025-11-22 111908](images\屏幕截图 2025-11-22 111908.png)

之后打开examples的对应示例项目，如：

![屏幕截图 2025-11-22 112125](images\屏幕截图 2025-11-22 112125.png)

其中main.cpp里就有简单的使用示例，基本只需要把它的代码粘贴到自己的项目就能用，非常方便。

> 2.整合ImGui进入自己的项目

目前Snail已经有了整体的 【应用-窗口-层栈】 结构，现在的目的是在引擎内部新创建一个ImGui层，该层可以被外部应用创建，外部应用可以推入层，并由内部应用类（Application）进行初始化和循环渲染。

第一步，创建ImGui层类，继承基础的Layer类

![屏幕截图 2025-11-22 112724](images\屏幕截图 2025-11-22 112724.png)

第二步，计划先实现OnAttach和OnUpdate两个方法，如果观察ImGui的使用示例可以发现，基本分为两个部分：

①ImGui的初始化②ImGui的循环渲染；

其实正好对应了OnAttach和OnUpdate两个方法，1.在层栈系统中，每个层应该在Push进入层栈成功之后，调用**OnAttach进行初始化**；2.之后在Application中的**OnUpdate循环渲染**。

## **值得注意的两个点是：**

### **一、ImGui的渲染流程中，会要求获取窗口的大小：**

![屏幕截图 2025-11-22 115410](images\屏幕截图 2025-11-22 115410.png)

而ImGui层类中现在无法获取属于Application类的窗口指针，所以写了一个获取窗口的getter方法;

inline Window& GetWindow() const {
	return *m_AppWindow;
}

但此时又发现一个问题，GetWindow()是Application类的成员函数，要调用它就必须先创建一个应用类实例，这时cherno才发现**Application逻辑上应该是一个单例**才对，一个Application的派生类就对应着一个引擎应用，在上述ImGui层类试图获取属于Application类的窗口指针时，绝对不能重新创建一个新的实例，而是**重复使用第一次构造Application类时的实例**。

所以进行如下修改：

![屏幕截图 2025-11-22 120334](images\屏幕截图 2025-11-22 120334.png)

1.在Application类中创建static实例变量和static的getter方法，表示只有唯一一个实例，**注意：**个人理解使用Application* 类型的原因：Application是基类，实际的实例往往是它的派生类，所以使用**基类指针可以指代派生类**而不是直接使用基类。

![屏幕截图 2025-11-22 120413](images\屏幕截图 2025-11-22 120413.png)

**注意：**.cpp必须额外添加一个

Application* Application::s_Instance = nullptr; 

对静态变量进行定义和初始化

2.在Application类的构造方法添加赋值操作，因为构造方法会自动创建一个实例this，只需要把它赋值给我们的s_Instance变量；添加一个断言检测。

![屏幕截图 2025-11-22 120425](F:\Snail\notes\images\屏幕截图 2025-11-22 120425.png)

3.析构函数删除变量s_Instance释放内存；Get方法实现，返回实例指针的解引用即可。

**注意错误：**我使用delete是错误的，这里不能自己释放单例，这里delete等同于delete this，不正确；单例的内存由创建它的人管理，也就是构造函数，也就是程序自身。

### 二、ImGui的渲染流程问题：

根据ImGui示例的main.cpp内容，ImGui的渲染流程是这样写的：

```
// main loop 开始------------------------------------

glfwPollEvents();

...ImGui的渲染...

glfwSwapBuffers(window);

//main loop 结束------------------------------------
```

而目前我的程序内流程是这样的：

```
while (m_Running) {
	glClearColor(1, 0, 1, 1);
	glClear(GL_COLOR_BUFFER_BIT);

	m_AppWindow->OnUpdate();
	//等价于：
	//glfwPollEvents();
	//glfwSwapBuffers(m_Window);

	this->OnUpdate();
	//等价于：
	// 层栈的渲染处理，由底层至顶层
    //for (Layer* layer : m_LayerStack) {
    //    layer->OnUpdate();
    //		     ↑ 这里才是我的...ImGui的渲染...
    //}

}
```

可见流程跟ImGui官方示例有点不太一样，不知道会不会产生问题，目前我对整个渲染流程以及这些语句的作用还不是很清楚。

> 3.莫名其妙，

不懂

```
int display_w = app.GetWindow().GetWindowWidth();

&display_w 
```

和

```
&(app.GetWindow().GetWindowWidth())
```

有啥区别，凭什么&(app.GetWindow().GetWindowWidth())报错E0158必须为左值或函数指示符

## 附上ImGui流程示例：

```
void ImGuiLayer::OnAttach() {
	// Setup Dear ImGui context
	IMGUI_CHECKVERSION();
	ImGui::CreateContext();

    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // Enable Docking
    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;       // Enable Multi-Viewport / Platform Windows

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    //ImGui::StyleColorsLight();

    // 初始化平台后端 (GLFW)
    Application& app = Application::Get();
    ImGui_ImplGlfw_InitForOpenGL(app.GetWindow().GetWindow(), false); // true 表示安装默认回调函数

    // 初始化渲染器后端 (OpenGL3)
    ImGui_ImplOpenGL3_Init("#version 410"); // 建议指定 GLSL 版本号

    }
    void ImGuiLayer::OnDetach() {
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplGlfw_Shutdown();
        ImGui::DestroyContext();
    }
    void ImGuiLayer::OnUpdate() {

    ImGuiIO& io = ImGui::GetIO();

    // Start the Dear ImGui frame
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    // 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).
    ImGui::ShowDemoWindow();

    // Rendering
    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);
    ImGui::Render();

    Application& app = Application::Get();
    int display_w = app.GetWindow().GetWindowWidth();
    int display_h = app.GetWindow().GetWindowHeight();

    io.DisplaySize = ImVec2(display_w, display_h);

    glfwGetFramebufferSize(app.GetWindow().GetWindow(), &display_w, & display_h);
    glViewport(0, 0, display_w, display_h);
    glClearColor(clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w);
    glClear(GL_COLOR_BUFFER_BIT);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    // Update and Render additional Platform Windows
    // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
    //  For this specific demo app we could also call glfwMakeContextCurrent(window) directly)
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        GLFWwindow* backup_current_context = glfwGetCurrentContext();
        ImGui::UpdatePlatformWindows();
        ImGui::RenderPlatformWindowsDefault();
        glfwMakeContextCurrent(backup_current_context);
    }

}
```

