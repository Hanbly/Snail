# 11.23关于virtual和文件结构的思考

> ## 1.virtual 的作用

c++中virtual关键字表示虚函数，目前我的理解它可以用来实现类的**多态**和**抽象类**编写，同时它的作用范围是基类以及派生类之间。

**一、实现多态：**

```
class Basic
{
public:
	inline virtual std::string GetClassName() {
		return "Basic";
	}
};
```

```
class Subclass : public Basic
{
public:
	inline virtual std::string GetClassName() override {
		return "Sub";
	}
};
```

使用：**Baisc e = new Subclass();** 

​			e.GetClassName();

如果像上面使用了virtual关键字则能正确调用Subclass的重写，反之只能调用基类的方法。

**二、实现抽象类：**

```
class Basic
{
public:
	virtual std::string GetClassName() = 0;
};
```

```
class Subclass : public Basic
{
public:
	inline virtual std::string GetClassName() override {
		return "Sub";
	}
};
```

这里Baisc基类由于含有纯虚函数，无法实例化，且Subclass也必须有对应纯虚函数的实现，否则无法实例化，这时Basic就是一个抽象类，基本只是声明一些共有特征和方法，不会提供实现，也不能实例化。

> ## 2.文件结构的思考

目前的文件结构如下：

![屏幕截图 2025-11-23 210829](images\屏幕截图 2025-11-23 210829.png)

与之前不同，现在我听取cherno的想法，他表示之后将会引入不同的操作系统支持、不同的图形库支持，甚至不同的操作后端（glfw）支持，所以创建一个Platform目录暂时存放所有存在特定依赖的编码的文件

![屏幕截图 2025-11-23 211138](images\屏幕截图 2025-11-23 211138.png)

如图Layer目录是通用的代码编写，Window目录是Window抽象类的代码，而它们其它的部分，目前基于windows或opengl的实现都放在Platform对应目录下，甚至把ImGui的特定库文件也放在了这里。

为了实现这种文件结构，其实也得益于我们之前写的Window抽象类和Input抽象类：

例如Input

```
namespace Snail {
	class SNAIL_API Input {
	private:
		static Input* s_Instance;
	protected:
		virtual std::pair<int, int> GetWindowSizeImpl() = 0;
	public:
		inline static std::pair<int, int> GetWindowSize() {
			return s_Instance->GetWindowSizeImpl();
		}
	};

}
```

```
namespace Snail {
	class WindowsInput : public Input {
	protected:
		inline virtual std::pair<int, int> 												GetWindowSizeImpl() override 
		{
			auto window = static_cast<GLFWwindow*>										(Application::Get()
							.GetWindow()
							.GetWindow());
			int width, height;
			glfwGetWindowSize(window, &width, &height);
			return { width, height };
		}
	public:
		WindowsInput() = default;
		~WindowsInput() = default;
	};
}
```

抽象类Input只声明了GetWindowSizeImpl而非定义它（我觉得用GetWindowSize再包装一层可能有点多此一举，声明一个唯一的纯虚函数再在派生类重写也一样吧？），之后在派生类实现GetWindowSizeImpl，这时就可以把具体的派生类代码写在Platform下，并区分不同平台的实现。