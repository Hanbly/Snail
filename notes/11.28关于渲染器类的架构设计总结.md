# 11.28关于渲染器类的架构设计总结

这里是对我在渲染器架构设计上的思考与改进的总结

### 1. 架构对比：Snail vs Hazel



- **我的实现 (Snail)**：采用了**双层结构**。
  - 将 Cherno 的 `RenderCommand`（静态代理）与 `RendererAPI`（虚基类接口）合并为单一的 `RendererCommand` 类。
  - `RendererCommand` 既定义了 `ClearImpl`、`DrawIndexedImpl` 等虚接口，又持有静态单例 `RC` 提供 `Clear`、`DrawIndexed` 等静态访问入口。
  - **优点**：代码更少，结构更紧凑，避免了单纯的“样板代码”转发，调用路径更短。
- **Cherno 的实现 (Hazel)**：采用了**三层结构**。
  - `Renderer` -> `RenderCommand` (静态代理) -> `RendererAPI` (虚接口)。
  - `Renderer` 不直接感知 API，而是通过 `RenderCommand` 转发。



### 2. 深度解析：为什么 Cherno 要写得这么繁琐？



看似“过度设计”的三层结构，核心目的是为了未来的**多线程渲染 (Multi-threaded Rendering)**：

- **RenderCommand 的真实身份**：不仅仅是转发器，未来它将充当 **“命令队列 (Command Queue)”** 的角色。游戏逻辑线程负责“发货”（Push命令），渲染线程负责“收货”（执行 API）。
- **当前状态**：在单线程（立即执行）模式下，这种拆分确实显得多余。
- **GraphicsContext 的特例**：为什么 `Context` 没有拆分？因为它只涉及初始化和交换缓冲区，通常是低频且阻塞的操作，不需要命令队列（YAGNI 原则）。

### 3. 结论与决策

- **当前策略**：保持目前的**双层合并结构**（Renderer -> RendererCommand）。这是反过度设计的务实选择。
- **未来扩展**：只要心里清楚 `RendererCommand` 目前是“立即执行”模式，未来若需要多线程支持，只需将内部的 `RC->DrawIndexedImpl()` 调用改为“推送到队列”即可，无需现在强行拆分文件。

```
#pragma once

#include "Snail/Core.h"

#include "Snail/Render/RenderAPI/VertexArray.h"

#include "glm/glm.hpp"

namespace Snail {

	class SNAIL_API RendererCommand
	{
	public:
		enum class API {
			None = 0,
			OpenGL,
			Vulkan
		};
		virtual ~RendererCommand() = default;

		inline static API GetAPI() {
			return s_API;
		}
	private:
		static API s_API;
	private: //----------Commands------------
		static std::unique_ptr<RendererCommand> RC;

		virtual void ClearColorImpl(const glm::vec4& color_RGBA) const = 0;
		virtual void ClearImpl() const = 0;
		virtual void DrawIndexedImpl(const std::shared_ptr<VertexArray>& vertexArray) const = 0;
	public:
		inline static void ClearColor(const glm::vec4& color_RGBA) {
			RC->ClearColorImpl(color_RGBA);
		}
		inline static void Clear() {
			RC->ClearImpl();
		}
		inline static void DrawIndexed(const std::shared_ptr<VertexArray>& vertexArray) {
			RC->DrawIndexedImpl(vertexArray);
		}

		static std::unique_ptr<RendererCommand> CreateRendererCommand();

		friend class Renderer;
	};

}

```

