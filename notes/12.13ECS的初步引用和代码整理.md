# 12.13ECS的初步引用和代码整理

## 1.ECS初步引入

ECS entity component system，之前没了解过，阐述一下概念：

这种系统包含两个部分，实体和组件，按照面向对象的思维，实体就是我的模型、相机、灯光，他们可以有一些属性比如音频、行为，那么这些就是组件？

在真正的ECS中，一切都是组件，我们的模型是组件，灯光是组件，音频也是组件，那什么是实体？实体实际上没有实体，实体就是一系列相关联的组件！在实现层面，实体就是一个整数标识id，用于关联不同类型的组件。 

### 使用的库

我们使用entt，一个实体组件系统库，它是个单文件库很方便使用。

entt的简单概念是，提供一个注册表registry，这里包含所有的entity（整数id），所有的component数据；我们可以用registery.create创建一个实体，然后registry.emplace<组件类型>（实体id）来为实体添加一个组件，这里可以同时传入组件对构造参数进行构造，结果其实是组件的数据和实体id绑定上了；之后我们可以registry.get<组件类型>(id)来获取实体的组件，返回结果就是我们的component&，这一套流程本质上就是帮助我们管理数据，可以通过entt的一系列其它方法更快速地获取数据&遍历数据，也就能更快地操作数据了。 


### 我做了什么

我进行的工作说实话有点粗糙，我继续在imgui窗口事件和离屏渲染后添加ECS的新内容，原本的SnailEditor层就已经非常臃肿了，其它代码结构也很混乱，但我想既然要添加ECS，也不如先实现，再重构，不然若先整理再添加，可能就要重构两次了... 


###### 创建Entity类：

Entity持有entt实体id，持有一个场景，所谓的场景对标的其实是entt中的注册表registry；Entity中主要写了一些模板函数，对应entt的组件添加、删除、获取、查询等等方法，并重构了一些操作符，能在一些简单操作中转换Entity和其成员id。

好像回到了写数据库命令的时候...说实话entt本身就像个数据库，这种编程方法也叫做面向数据思想。  

###### 创建Scene类：

它持有一个entt注册表registry，还拥有创建实体、删除实体的函数，对于这个，我们确实不会希望Entity用自己的构造方法创建实体，而是向某个场景中拖进去一个实体来创建，实践层面来看，实体的创建依赖于registry，所以也确实必须由一个场景来管理在它其中的所有实体；场景类还有一些重要的函数，这也是我今天痛苦的由来：OnUpdate和OnEditorRender。

这部分是我让ai写的，我或许要考虑自己重新写一下，ai纠结于我的camera结构，一开始我是希望camera也变成ECS的一部分，作为组件在Editor层创建，并由一个场景Scene同其他实体一起更新，但ai始终纠结于我应该区分一个编辑器相机出来，编辑器的相机不应该参与进ECS，它就是Editor层的一个成员...对与这点，我现在也挺疑惑的。但是总之，我没有大改整个编辑层的逻辑，只是把原来直接创建的Model类、Mesh类等等的后面，又加了几行scene.createentity、entity.addcomponent等等，然后把OnRender逻辑中的遍历挪到了scene的OnEditorRender中。

经历今天，我永远记住Scene的拼写了，再也不会写成Scence或Sence了。 


## 2.代码整理

非常痛苦的部分，首先我优化了相机部分，Camera持有其自身的fov、长宽比、近远点这些数据和一个projection矩阵，为什么不持有其它数据比如位置、轴向量？甚至没有view矩阵？

之前我其实没有意识到，相机的view矩阵本身就约等于相机的model矩阵，只不过二者有一个逆矩阵的关系，因为view的意义就是view * 物体/世界坐标系，把对方坐标系转换成相机坐标系来观察，那么反过来，inverse(view) * 相机，不就是把相机作为物体转换刀世界坐标系的过程吗？

所以Camera或Controller都不再持有view，而是作为一个通用组件Transform联系在相机实体上（不管什么实体都可以有一个Transform组件，所以让它通用，创建实体的时候就直接add了）。

那么为什么没有位置这些属性，因为Camera只拥有相机的内部属性，比如它的整个视锥体的属性，而位置、移动、方向这些其实是外部属性，是相对于外部才具备的属性，一个相机本身是没有位置和方向可言的，所以把它们放在Controller里。

  