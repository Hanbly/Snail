# 11.27GLFW的窗口与Application的析构问题



## 首先回顾一下Snail::CreateApplication()是如何工作的？



Snail::CreateApplication()声明在Snail/Application.h之中，但Snail不进行定义实现，而是在客户端Example进行定义：

```
Snail::Application* Snail::CreateApplication()
{
	return new Example();
}
```

再在程序入口Snail/EntryPoint.h进行**真正的调用**：

```
#ifdef SNL_PLATFORM_WINDOWS

	extern Snail::Application* Snail::CreateApplication();

	int main(int argc, char** argv)
	{
		// windows特化代码-解决控制台编码问题
		SetConsoleOutputCP(CP_UTF8); 
		
		Snail::Log::InitLoggers();
		auto app = Snail::CreateApplication();
		app->run();
		delete app;
	}

#endif
```

extern表示该函数定义在外部，因为CreateApplication**调用在Snail**而**定义在Example**，所以需要声明一下extern。

> ## **使用GLFW窗口后产生的析构问题**

// 崩溃点在于：**delete app** -> **~Window** -> **glfwDestroyWindow()**
// 此时试图去销毁一个依附于“已关闭的GLFW库”的窗口，导致访问越界

### **1.为什么点击窗口关闭按钮最终导致了 Window 析构？**



点击关闭按钮并不会**直接**触发 C++ 的析构函数。实际发生的连锁反应如下：

1. **用户点击关闭 (X)**：GLFW 捕获到操作系统信号。
2. **回调触发**：GLFW 调用你设置的 `glfwSetWindowCloseCallback`。
3. **事件分发**：你的代码生成 `WindowCloseEvent` 并分发给 `Application::OnWindowClose`。
4. **修改标志位**：`OnWindowClose` 执行 `m_Running = false;`。
5. **退出循环**：`Application::run()` 中的 `while (m_Running)` 循环检测到条件为假，**函数返回**。
6. **回到 main 函数**：`app->run()` 执行完毕，程序继续向下执行。
7. **执行 delete**：你的 `main` 函数中（通常在 `run()` 之后）写了 `delete app;`。
8. **触发析构**：正是这行 `delete app;` 触发了 `Application` 的析构，进而导致了 `Window` 的析构（详见下一点）。

**结论**：点击关闭按钮只是“拉响了下班的铃声（`m_Running=false`）”，而真正“拆除办公楼（析构 Window）”的操作是在下班后执行 `delete app` 时发生的。

### **2. 为什么 `delete app` 会触发 Window 的析构？**



因为 `Application` 构造函数中使用了 **智能指针 (std::unique_ptr)**。

```
// Application.cpp
m_AppWindow = std::unique_ptr<Window>(Window::SNLCreateWindow());
```

**机制解释：**

1. **所有权（Ownership）**：`std::unique_ptr` 拥有它所指向的对象。这意味着 `m_AppWindow` 拥有那个 `WindowsWindow` 实例。
2. **级联析构**：
   - 当你调用 `delete app` 时，编译器调用 `~Application()` 析构函数。
   - C++ 规则规定：在类的析构函数执行完后，会自动销毁该类的所有 **成员变量**。
   - 因此，`m_AppWindow`（这个智能指针对象）被销毁。
3. **智能指针的特性**：`std::unique_ptr` 的析构函数包含类似这样的逻辑：`if (ptr) delete ptr;`。
4. **最终结果**：智能指针自动对其管理的 `WindowsWindow` 指针执行了 `delete`，从而触发了 `WindowsWindow::~WindowsWindow()`，最后调用了 `glfwDestroyWindow`。

**如果你使用的是裸指针 (Window\* m_AppWindow)**： 那么 `delete app` **不会** 自动销毁窗口，除非你在 `~Application()` 里显式写了 `delete m_AppWindow;`，否则就会造成内存泄漏（窗口没关，但 App 对象没了）。

### 3.原因

delete app没有错，错在于：

在delete app之前，**RenderContext类**的派生类实现中，析构函数调用了glfwDestroyWindow()，所以当delete app时试图**重复释放**内存，所以发生了错误。