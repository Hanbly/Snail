# 11.28相机系统的原理

## 1.相机是一个概念

相机是一个抽象概念，引擎系统并不存在真正的相机。相机系统实际上是在定义我们的屏幕如何展示场景，如何展示物体。

一个相机可以有很多属性，比如坐标、方向、视角、纵横比等等

## 2.相机的视野（filed of view）

我想把这个概念理解为相机的**可视范围**，它最重要的属性是**可视角范围**，这个范围就是可视角的角度，叫做**FOV**也就是 filed of view 的简称，可以以角度（45°/65°/90°）作为值。

## 3.想象到底会发生什么

我们只在屏幕上展示**场景和物体**，相机的移动时，所有其它事物就会发生相对移动。例如相机向上平行移动的时候，物体A在镜头里会逐渐靠近下边框，实际上在相机只是抽象概念的情况下，实际发生的事情就是物体A逐渐向下平行移动了，可以发现相机的移动和其它事物的相对移动是**完全颠倒**的。

这其实就涉及到所谓**视图矩阵以及投影矩阵**的变换。

## 4.数据涉及到哪些

我们的物体会有它的**模型矩阵**;

我们的相机有一个**视图矩阵**，和一个**投影矩阵**。

cherno给出公式：

### view * proj * model * vertexPos（顶点在局部坐标系的位置）

![屏幕截图 2025-11-29 110500](images\屏幕截图 2025-11-29 110500.png)

#### 1. `view`：视图矩阵（View Matrix）

作用：将顶点的 “世界坐标” 转换为 “观察坐标”（相机空间坐标）。

核心功能：模拟相机的视角和位置

—— 相当于 “把相机放在场景中的某个位置，看向某个方向”，所有顶点都会相对于相机重新计算坐标。

- 相机移动：比如相机从 (10,10,10) 移到 (8,8,8)，所有顶点的坐标都会相对于新相机位置偏移；
- 相机旋转：比如相机从看前方转为看左方，顶点的 “观察坐标” 会相应翻转。

- 通俗理解：相当于你在场景中 “换了个站的位置和看的方向”，你看到的物体位置会变化，但物体本身在场景中的位置（世界坐标）没动。

#### 2. `proj`：投影矩阵（Projection Matrix）

作用：将顶点的 “观察坐标” 转换为 “裁剪坐标”，最终映射为 “屏幕坐标”。

核心功能：模拟人眼 / 相机的 “透视效果” 或 “正交效果”，解决 “3D 物体如何显示在 2D 屏幕上” 的问题。

- 透视投影（最常用）：远处的物体看起来更小，符合人眼规律（比如公路向远方汇聚）；
- 正交投影：物体大小和距离无关，常用于 2D 游戏、CAD 软件（比如 Unity 的 UI 界面、AutoCAD 的绘图模式）。

- 关键：投影矩阵会将 3D 坐标 “压平” 为 2D 坐标，同时定义 “可见范围”（比如相机能看到的最近 / 最远距离、视野角度等）—— 超出范围的顶点会被裁剪，不显示在屏幕上。

#### 3. `model`：模型矩阵（Model Matrix）

作用：将顶点的 “局部坐标” 转换为 “世界坐标”（场景空间坐标）。

核心功能：包含模型的平移（移动）、旋转、缩放

操作。

- 平移：模型在场景中从 A 点移到 B 点（比如从 (0,0,0) 移到 (5,2,3)）；
- 旋转：模型绕 X/Y/Z 轴旋转（比如绕 Y 轴转 90 度）；
- 缩放：模型放大或缩小（比如放大 2 倍，或缩小到 0.5 倍）。

- 示例：如果模型矩阵包含 “沿 X 轴平移 5 个单位”，那么原始坐标 `(0.5, 0.5, 0.5)` 会变成 `(5.5, 0.5, 0.5)`，即 “在场景中 X=5.5 的位置”。

#### 4. `vertexPos`：顶点的 “局部坐标”（模型空间坐标）

定义：3D 模型文件（如.obj、.fbx）中存储的顶点原始坐标，是相对于**模型自身中心点**的坐标。

- 示例：比如一个立方体的顶点坐标可能是 `(0.5, 0.5, 0.5)`，意思是 “在模型中心点的右、上、前方向各 0.5 个单位”。
- 特点：和场景、相机无关，只属于模型本身 —— 哪怕模型移动到场景的任何位置，它的 `vertexPos` 永远不变。

## 5.向量依靠矩阵变换的原理

参考链接：https://bilibili.com/BV1Ya411J79R

想像一个平面向量：

![屏幕截图 2025-11-29 203112](images\屏幕截图 2025-11-29 203112.png)

当向量（1，2）乘以单位矩阵时，会得到它本身（1，2），这时我们可以把向量表示为矩阵形式：

![屏幕截图 2025-11-29 203532](images\屏幕截图 2025-11-29 203532.png)  === 向量（1，2）

当我们变换基向量的时候，结果也会相应变化：

①放大x轴乘2：

![屏幕截图 2025-11-29 203832](images\屏幕截图 2025-11-29 203832.png)

②放大y轴乘2：

![屏幕截图 2025-11-29 203923](images\屏幕截图 2025-11-29 203923.png)

③y轴畸变（倾斜）![屏幕截图 2025-11-29 203943](images\屏幕截图 2025-11-29 203943.png)

这时可以发现一个特征，如果始终把红色和绿色的轴向量视作一个单位长度，那么最终的**结果向量**仍然是新坐标系下的（1，2）。



这里引申出一个概念：红色和绿色的轴向量被称作**基向量**，它们能够表示某一个坐标系，向量（px, py）能够表示**坐标系的x轴**，（qx, qy）则表示坐标系的**y轴**。

![屏幕截图 2025-11-29 204411](images\屏幕截图 2025-11-29 204411.png)（x，y）是某个固有比例的向量，当它分别乘以新的坐标系的基向量时，得到的其实就是某种 **缩放/旋转/移动** 后的，基于新的坐标系的新向量！

这时就可以尝试理解之前的公式的其中一部分了：**局部模型-世界坐标系**：我的模型有一堆局部的顶点数据，比如A点距离原点有（0.5f, 0.0f, 0.5f），这就相当于原有向量（x，y）；当我想把它转置到世界坐标系时，我只需要乘一个世界坐标系的基向量所组成的矩阵，例如世界坐标系的x&y轴都要比现在大10倍，那么计算结果就能按比例得到（5.0f, 0.0f, 5.0f）。

### 1.缩放

这种情况比较简单，因为基向量的方向（不包括负方向）是不会变的，当我想按比例扩大10倍，那么就把所有基向量的长度乘10；如果我想让结果指向原本的反方向，那么我只需要让所有的基向量乘-1，指向其各自的反方向。

### 2.旋转

![屏幕截图 2025-11-29 211239](images\屏幕截图 2025-11-29 211239.png)

假设逆时针旋转一个角度，这时

x基向量变成（cos, sin）而y基向量变成（-sin, cos），组成矩阵就是

![屏幕截图 2025-11-29 211551](images\屏幕截图 2025-11-29 211551.png)

### 3.移动

移动实际上是向量的加法，如图表示，进行旋转或缩放可以直观地通过矩阵乘法来实现，而只有在最后加上一个移动向量，才能表示移动：

![屏幕截图 2025-11-29 213444](images\屏幕截图 2025-11-29 213444.png)

那么如何解决呢？使用以下技巧：

![屏幕截图 2025-11-29 213929](F:\Snail\notes\images\屏幕截图 2025-11-29 213929.png)

图中看到我们在原有的矩阵中添加了一行一列，并在原有向量添加了一个1。

### 6.矩阵与向量相乘的顺序

矩阵相乘满足结合率，但不满足交换律：

Mat1 * Mat2 * Mat3 * Mat4 * 向量v

实际上由于矩阵满足结合律，这个式子等价于向量v先与Mat4相乘，再与Mat3...

而不可能是先与Mat3/2/1，因为向量v无法越过Mat4先与之前的矩阵相乘。

