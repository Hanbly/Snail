# 11.21层栈的遍历&层栈的迭代器问题

```
// 层栈的事件处理，由顶层至底层
for (auto it = m_LayerStack.GetEnd(); it >= m_LayerStack.GetBegin(); it--) {
	(*it)->OnEvent(e);
	if (e.GetIsHandled()) { break; }
}
```

```
// 层栈的渲染处理，由底层至顶层
for (auto it = m_LayerStack.GetBegin(); it < m_LayerStack.GetEnd(); it++) {
	(*it)->OnUpdate();
}
```

> 1.层的构造错误：

运行时错误：0x00007FF9D708B336 (Snail.dll)处(位于 Example.exe 中)引发的异常: 0xC0000005: 读取位置 0x0000000000000018 时发生访问冲突。
位置：(*it)->OnUpdate();

原因：栈分配和堆分配！

	Example() {
	    ExampleLayer layer("example层");
	    this->PushNorLayer(&layer);
	}
layer在构造函数结束时就没了，应该用：

​	this->PushNorLayer(new ExampleLayer("example层"));

> 2.vector错误断言：

vector在程序运行时，具体来说是当我触发窗口的事件时，突然抛出断言：Debug Assertion Failed!

Program: F:\Snail\bin\Debug-windows-x86_64\Example\Snail.dll
File: C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
Line: 56

Expression: can't dereference out of range vector iterator

For information on how your program can cause an assertion
failure, see the Visual C++ documentation on asserts.

(Press Retry to debug the application)
“Example.exe”(Win32): 已加载“C:\Windows\System32\TextShaping.dll”。包含/排除设置已禁用符号加载。
Second Chance Assertion Failed: File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector, Line 56
已在 Example.exe 中执行断点指令(__debugbreak()语句或类似调用)。

调试停在app->run();，

控制台输出...[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Application]: ExampleLayer 调用: OnUpdate()
[01:28:46] [Snail]: [窗口移动事件] 当前窗口位置: X-206|Y-236
[01:28:46] [Snail]: [窗口失焦事件]，

说明循环能在一开始进行，但一旦触发glfw和我的对应回调方法就会崩溃

***!!!  原因  !!!***

我原本的迭代方法：

```
//反向迭代

// 层栈的事件处理，由顶层至底层
for (auto it = m_LayerStack.GetEnd(); it >= m_LayerStack.GetBegin(); it--) {
	(*it)->OnEvent(e);
	if (e.GetIsHandled()) { break; }
}
```

```
//正向迭代

// 层栈的渲染处理，由底层至顶层
for (auto it = m_LayerStack.GetBegin(); it <= m_LayerStack.GetEnd(); it++) {
	(*it)->OnUpdate();
}
```

正确的方式：

首先实现两个正向&两个反向迭代器：

std::vector<Layer*>::iterator LayerStack::begin() {
	return m_Layers.begin();
}
std::vector<Layer*>::iterator LayerStack::end() {
	return m_Layers.end();
}

std::vector<Layer*>::reverse_iterator LayerStack::rbegin() { 
	return m_Layers.rbegin(); 
}
std::vector<Layer*>::reverse_iterator LayerStack::rend() { 
	return m_Layers.rend(); 
}

正确的迭代：

```
// 层栈的事件处理，由顶层至底层
for (auto it = m_LayerStack.rbegin(); it != m_LayerStack.rend(); it++) {
	(*it)->OnEvent(e);
	if (e.GetIsHandled()) { break; }
}
```

```
// 层栈的渲染处理，由底层至顶层
for (Layer* layer : m_LayerStack) {
	layer->OnUpdate();
}
```

**注意！这种方法必须实现m_LayerStack对象的begin()&end()方法，否则无法使用，begin()&end()名字不能随便改。**

使用std::vector<>::reverse_iterator之后，vector的错误消失了，究其原因，分析之前的两种迭代方法：

重点是对m_LayerStack.GetEnd()的理解有错误。

vector.end()是数组最后一个元素的下一个位置，当我反向迭代时，初始化auto it = m_LayerStack.GetEnd()，直接导致第一次调用(*it)-> OnEvent(e)就会失败；当我正向迭代时，边界条件it <= m_LayerStack.GetEnd()会导致最后一次调用(*it)->OnUpdate(e)失败...

而之后的迭代方法正确在于：

- **rbegin()** (reverse begin)：返回一个指向**最后一个元素**的反向迭代器。
- **rend()** (reverse end)：返回一个指向**第一个元素之前**的“哨兵”位置的反向迭代器。

反向迭代从最后一个有效元素开始，it++ (对反向迭代器进行递增) 会使它移向容器的前一个元素。当 it 最终等于 rend() 时，循环正确终止，绝不会解引用无效的 rend()。

**基于范围的** **for** **循环**for (Layer* layer : m_LayerStack)它内部自动使用了正确的 != __end 作为循环条件，因此它是安全、简洁且推荐的写法。

> 2.层栈对象维护一个永久迭代器的隐患：

std::vector 的迭代器是一种非常“脆弱”的东西。它们本质上是指向 vector 内部连续内存块中某个位置的指针或类似指针的对象。任何可能改变 vector 内部内存布局的操作，都可能导致迭代器失效。

#### 场景 1：push_back 或 insert 导致内存重分配

插入vector时如果容量超出限定，则会触发内存重新分配，在另一个区域分配内存后把原有的数据拷贝过去，这会导致整个vector中的迭代器全部失效。

#### 场景 2：insert 未导致内存重分配，但使部分迭代器失效

即使 vector 的容量足够，insert 操作也会使**插入点以及之后的所有迭代器**失效。

m_Layers.insert(pos, value);

所有在 pos 位置或之后的迭代器都会失效。

我的代码中使用了m_InsertPointer = m_Layers.insert(m_InsertPointer, norLayer) + 1;
在这里重新赋值了 m_InsertPointer，所以它本身在这种情况下是有效的。这个风险在当前代码中可能不明显。

#### 场景 3：erase 操作导致迭代器失效

PopNorLayer 和 PopOverLayer 中的 m_Layers.erase(it) 操作也会导致迭代器失效。原理与插入相同。

m_Layers.erase(it);

it 以及它之后的所有迭代器都会失效。

PopNorLayer 实现：

```
auto it = std::find(m_Layers.begin(), m_InsertPointer, norLayer);
if (it < m_InsertPointer) {
    m_Layers.erase(it); // <--- 问题点
    m_InsertPointer--; // <--- 危险操作
}
```

1. **m_Layers.erase(it)**：这个操作使所有从 it 位置开始的迭代器（包括 m_InsertPointer，如果 it 在它之前的话）都失效了。
2. **m_InsertPointer--**：可能在对一个**已经失效**的迭代器进行递减操作，这也是未定义行为。即使它看起来能工作（因为内存可能还没被覆盖），但这在逻辑上是错误的，并且依赖于未定义的实现细节。