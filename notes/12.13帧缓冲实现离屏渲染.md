# 12.13帧缓冲实现离屏渲染 

帧缓冲是什么

帧缓冲即framebuffer，与vbo有点类似。一个帧缓冲buffer需要生成函数

```
glGenFramebuffers(1, &id)，
```

然后需要绑定它

```
glBindFramebuffer(GL_FRAMEBUFFER, fbo)，
```

在绑定后，framebuffer类似于模板测试缓冲区，所有此时进行的绘制操作都将影响帧缓冲；为了能够使这个帧缓冲有效，还要进行附件的绑定：大致分为**颜色附件，深度附件，模板附件，和渲染缓冲对象附件**。

基本就跟之前的渲染流程是对应的，颜色附件可以**创建一个纹理**作为颜色附件，当我们绑定帧缓冲后所有渲染命令都会把结果写入这个纹理中，所以我们还需要指定一个渲染缓冲对象附件（我理解就是深度测试和模板测试的集合），或分别指定两个测试附件，制定附件完成后，我们就可以正常Bind帧缓冲了。注意应该在初始化和绘制命令完成后，均记得解绑帧缓冲，否则会意外写入。

之后在imgui的视口或一些面板中，调用 

```
// 获取帧缓冲信息，绘制纹理
uint32_t textureId = fbo->GetColorAttachment();
ImGui::Image(
    (void*)(intptr_t)textureId,	
    ImGui::GetContentRegionAvail(),
    ImVec2(0, 1), // UV0: 纹理的(0,1) -> 对应 OpenGL 左上
    ImVec2(1, 0)  // UV1: 纹理的(1,0) -> 对应 OpenGL 右下
);
```

 把帧缓冲的颜色附件当成纹理（图片）输出到imgui窗口。 
 ![屏幕截图 2025-12-12 123740](images\屏幕截图 2025-12-12 123740.png)

