# 12.5性能分析

性能分析是什么？

性能分析是通过某种方法收集我们程序的运行数据，如某个作用域的运行时间，某些函数的运行次序和关系，然后综合分析程序性能瓶颈。

方法就是利用类class栈对象的析构方法在作用域结束时被调用的特性，创建Timer类：

## 1.计时器类

```
struct ProfileResult {
	std::string name;
	long long start, end;
	uint64_t threadID;
};
extern std::vector<ProfileResult> s_ProfilingResults;



template<typename Fn>
class Timer {
private:
	std::chrono::time_point<std::chrono::steady_clock> m_StartTimepoint;
    std::string m_Name;
	Fn m_Function;
public:
	Timer(const std::string& name, Fn&& func)
		: m_Name(name), m_Function(func){
		m_StartTimepoint = std::chrono::high_resolution_clock::now();
	}

	~Timer(){
		auto EndTimepoint =                std::chrono::high_resolution_clock::now();

		long long start = std::chrono::time_point_cast<std::chrono::microseconds>(m_StartTimepoint).time_since_epoch().count();
		long long end = std::chrono::time_point_cast<std::chrono::microseconds>(EndTimepoint).time_since_epoch().count();
		
		auto duration = (end - start) * 0.001f;
	}
};
```

这时获取的数据可以打印在控制台，也可以通过Imgui窗口实时显示在渲染的过程中，但是并不方便获取到一个文件中进行分析，更没有可视化方法，只能看到一些不直观的数字。

## 2.输出到文件

我们通过一个Instrumentor类将数据格式化输出到.json文件中，这种文件应该可以被chrome://tracing 直接分析并给出可视化结构。

这部分我看了cherno的c++系列中的基准测试一节  BV1gZ4y1R7SG，并直接copy  https://github.com/GavinSun0921/InstrumentorTimer  这位的代码，感谢。

之后在Timer类添加

```
uint64_t threadID = std::hash<std::thread::id>{}(std::this_thread::get_id());
Instrumentor::WriteProfile({ m_Name, start, end, threadID });

m_Function({ m_Name, start, end, threadID });
```

值得一提m_Function我传入的是

\[&\](Snail::ProfileResult pr){ Snail::s_ProfilingResults.push_back(pr); }

这个lambda式，作用是向s_ProfilingResults这个静态全局vector变量中加入新的测试结果（保存着之前所有的性能测试结果），如果只是使用Instrumentor输出到文件然后可视化的话，不需要这个东西，它的存在是为了方便后面将数据从内部输出，比如imgui界面上。

目前不使用时，动态维护几十个函数和作用域的性能测试可能挺费性能的，其实可以考虑去掉。

## 3.可视化

![屏幕截图 2025-12-05 183603](images\屏幕截图 2025-12-05 183603.png)

如图，显然好处很多，我们可以看到每个函数的运行时间，可以看到每次submit立方体我的方法是以什么顺序被调用的，整个流程的性能消耗又是多少。