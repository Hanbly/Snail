# 11.26Shader简单使用引出的的要点和误区

## 1.智能指针与 OpenGL 资源的生命周期管理

**核心要点**：在初始化 OpenGL 封装对象（如 Shader）时，绝对不要创建临时对象。临时对象的析构函数会立即执行，导致 OpenGL 句柄（ID）在这一行代码结束时就被 glDelete 删除了，后续使用的是无效 ID。

```
// ❌ 错误：产生临时对象 -> 立即析构 -> ID被删除
m_Shader = std::make_unique<Shader>(Shader(vertexSrc, fragSrc));

// ✅ 正确：直接传参，在堆上原位构造对象，ID 保持存活
m_Shader = std::make_unique<Shader>(vertexSrc, fragSrc);
```

## 2.标准渲染循环的执行顺序

**核心要点**：每一帧必须遵循严格的顺序。**清屏**必须在最开始，**交换缓冲区**必须在最后。如果你在 Swap 之后绘制，画面会闪烁或黑屏；如果你在 Update 之后绘制，会有输入延迟。

```
void Application::OnUpdate() {
    glClear(GL_COLOR_BUFFER_BIT);  // 1. 先清屏
    
    // ...Update 逻辑...

    // 2. 绘制场景 (三角形)			 }
    m_Shader->Bind();				   }
    glDrawElements(...);				 } 这几步
									     } Render渲染逻辑
    // 3. 绘制 UI (ImGui)				  }
    m_ImGuiLayer->OnRender(); 		  }

    m_AppWindow->OnUpdate();       // 4. 最后交换缓冲区 (SwapBuffers)
}
```

## 3.ImGui 覆盖层的绘制逻辑误区

**核心要点**：ImGui 是 UI 覆盖层（Overlay），它绘制在已经画好的 3D 场景之上。因此，在 ImGuiLayer::EndImGui 或其渲染阶段，**绝对不能调用 glClear**，否则会把背景里的 3D 场景擦除，只剩下 UI。

```
void ImGuiLayer::EndImGui() {
    ImGui::Render();
    // ❌ 绝对不要在这里写 glClear(GL_COLOR_BUFFER_BIT);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
}
```

## 4.引擎架构的职责分离

**核心要点**：Application::run 或 OnUpdate 不应包含具体的 OpenGL 绘制指令（如 glDrawElements）。应将绘制逻辑封装到具体的 Layer 子类中，由 Application 统一调度 layer->OnRender()，保持主循环代码整洁。

```
// 将绘制代码移入具体的层
class GameLayer : public Layer {
    void OnRender() override {
        m_Shader->Bind();
        glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, nullptr);
    }
};

// Application 中只负责调度
for (Layer* layer : m_LayerStack) layer->OnRender();
```

## 5.OpenGL 状态解绑与几何方向

**核心要点**：解绑 Shader 或 Buffer 时，OpenGL 的标准做法是绑定 ID 为 0 的对象。此外，三角形索引顺序决定了正面朝向（默认逆时针 CCW 为正面），顺序错误会导致开启面剔除后物体消失。

```
// 解绑 Shader
void Shader::UnBind() const { glUseProgram(0); }

// 顶点索引顺序 (逆时针)
unsigned int indices[] = { 0, 1, 2 };
```

