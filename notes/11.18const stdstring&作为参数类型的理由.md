# 11.18const std::string&作为参数类型的理由

![img](images\屏幕截图 2025-11-18 173135.png)

为什么要写成const std::string&的类型？

![Thinking](https://www.gstatic.com/aistudio/watermark/watermark.png)

將參數類型寫成 const std::string& 主要有兩個原因，我們把它拆開來看：& (引用) 和 const (常量)。

------



### 1. & (引用) - 為了效率，避免拷貝

在C++中，函數參數默認是**按值傳遞 (pass-by-value)** 的。這意味著當你調用函數時，會創建一個傳入參數的**副本**。

- **如果不使用 &**，參數類型是 std::string：

  codeC++

  

  

  ```
  WindowProps(std::string title)
  ```

  當你這樣調用時：WindowProps("My Awesome Game")，會發生以下事情：

  1. "My Awesome Game" 這個字符串字面量首先會被用來創建一個臨時的 std::string 對象。
  2. 這個臨時的 std::string 對象會被**拷貝**一份，作為 title 參數傳入 WindowProps 的構造函數。
  3. 這個拷貝操作可能涉及**內存分配**和**字符數據的逐個複製**，特別是當字符串很長時，這是一個相對昂貴的操作。

- **如果使用 &**，參數類型是 std::string&：

  codeC++

  

  

  ```
  WindowProps(const std::string& title)
  ```

  當你調用時，傳入的是原始 std::string 對象的**引用**（可以理解為一個別名）。

  1. 沒有發生任何拷貝。函數直接使用你傳入的那個字符串對象。
  2. 這極大地提高了效率，因為它避免了不必要的內存分配和數據複製。對於 std::string 這種可能很大的對象來說，性能提升非常顯著。

**小結：使用 & (引用) 是為了性能，避免創建昂貴的臨時副本。**

------



### 2. const (常量) - 為了安全和靈活性

現在我們知道了 & 的好處，但為什麼還要加上 const 呢？

- **第一：安全性和代碼意圖 (Safety and Intent)**
  const 是一個承諾。它告訴函數的調用者和編譯器：“我（這個函數）只會讀取這個字符串，我保證不會修改它。”

  - **對調用者**：當你看到一個函數的參數是 const 引用時，你可以放心地把你的變量傳進去，不用擔心它在函數內部被意外修改。
  - **對編譯器**：如果函數的實現代碼試圖修改 title（例如 title += "!"），編譯器會立刻報錯，從而防止了潛在的bug。

- **第二：靈活性 - 接受臨時對象 (Accepting Temporaries/Literals)**
  這是 const 非常重要的一個作用。一個**非 const 的左值引用 (std::string&)** 不能綁定到一個**臨時對象 (右值)**。

  看下面的例子：

  codeC++

  

  

  ```
  void printTitle_NonConst(std::string& title) { /* ... */ }
  void printTitle_Const(const std::string& title) { /* ... */ }
  
  std::string myGame = "My Game";
  
  // 情況 1: 傳入一個變量 (左值)
  printTitle_NonConst(myGame); // OK
  printTitle_Const(myGame);    // OK
  
  // 情況 2: 傳入一個字符串字面量 (臨時對象/右值)
  printTitle_NonConst("Hazel Engine"); // 錯誤！編譯不通過！
  printTitle_Const("Hazel Engine");    // OK！const引用可以綁定到臨時對象
  ```

  在你的代碼中，WindowProps 的構造函數設置了默認值 = "Hazel Engine"。這個默認值是一個字符串字面量，它是一個臨時對象（右值）。如果參數類型是 std::string&（沒有 const），那麼 WindowProps() 這樣的默認調用就會編譯失敗。

  加上 const 之後，const std::string& 既可以接受像 myGame 這樣的變量，也可以接受像 "Hazel Engine" 這樣的字面量，使得函數的適用性更廣。

------



### 總結

const std::string& 是一個在C++中非常常見且推薦的 "黃金組合"，用於傳遞那些你**只想讀取而不想修改**的複雜對象（如 string, vector 等）。

它結合了兩方面的優點：

1. **& (引用) 帶來的性能**：避免了不必要的對象拷貝。
2. **const (常量) 帶來的安全性和靈活性**：保證原始數據不被修改，並且能夠接受各種輸入（變量、字面量、函數返回值等）。