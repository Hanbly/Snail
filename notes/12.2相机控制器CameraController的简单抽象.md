# 12.2相机控制器CameraController的简单抽象

为什么抽象一个控制器？

因为Camera目前有两部分功能：

1.存储数据（位置、基向量、转换矩阵）

2.处理数据（比如移动方法：switch键值&重新计算矩阵）

控制器的目的是把处理数据的部分解耦出来



## **实现**

CameraController 的大致结构：

```
class PerspectiveCameraController {
public:
	PerspectiveCameraController(const float& fov, const float& aspect, const glm::vec3& position);
	~PerspectiveCameraController() = default;

	void RecalculateMatrix();
	void RecalculateVectors();

	void MoveCamera(const Camera::TranslationDirection& dir, const float& length);
	void RotateCamera(const float& yaw, const float& pitch);
	void UpdateZoomFov(const float& fovOffset);
	void UpdateAspect(const float& aspect);

	void OnUpdate(const Timestep& ts);
	void OnEvent(Event& e);

	inline const Uniptr<Camera>& GetCamera() const { return m_Camera; }
private:
	bool OnWindowResize(WindowResizeEvent& e);
	bool OnMouseMove(MouseMoveEvent& e);
	bool OnMouseScroll(MouseScrollEvent& e);
private:
	Uniptr<Camera> m_Camera;
	float m_CameraMoveSpeed = 5.0f;

	float m_LastMouseX;
	float m_LastMouseY;
	bool  m_FirstMouse = true; // 第一帧标志位
	float m_Sensitivity = 0.1f; // 灵敏度
};
```

类属性方面，控制器持有其唯一的相机对象指针，持有平移速度、鼠标位置信息&灵敏度（用于视角旋转方法）；

类公有方法中，有构造&析构、基向量及矩阵的计算、处理相机平移的方法、以及OnUpdate和OnEvent，后面实现时将平移的键值判断放在OnUpdate，鼠标/窗口的事件判断放在OnEvent分发下的各个事件方法中；

类私有方法中，有处理事件的一些方法，当触发OnEvent时，用事件方法器调用对应的方法。





总体来说，控制器的初步抽象只需将原有的数据处理方法移至本类即可。