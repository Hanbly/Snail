# 12.6光照

## 一、图形学的光照是什么？

现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，通过有限的数据模拟真实世界中无限复杂的光照，所以这种模型是基于我们对光的物理特性的理解，其中一个模型被称为冯氏光照模型(Phong Lighting Model)。

## 二、冯氏光照模型

冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：

![basic_lighting_phong](F:/Snail/notes/images/basic_lighting_phong.png)

- 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。
- 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是风氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。
- 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

### Ⅰ.环境光照

环境光照的实现非常简单，其实类似于我之前实现过的物体颜色的变化控制。我们默认这个世界有各种微弱的环境光照，即便没有特定的光源存在，所以我们通过设置一个**光照颜色** vec4 LightColor(1.0f, 1.0f, 1.0f, 1.0f) 并乘以一个**环境光照系数**  vec3 ambientStrength(0.1) （只影响RGB三个通道），就能模拟出没有光源情况下，物体所显现出的**其自身的颜色特征**。

![屏幕截图 2025-12-06 114034](images\屏幕截图 2025-12-06 114034.png)

##### 具体实现：

**物体**的片元着色器接收一个光照颜色向量vec4 u_LightColor，然后乘以一个给定的环境光照系数vec3(0.1f)，

vec3 ambientStrength = vec3(0.1);
vec4 ambient = vec4(ambientStrength, 1.0) * u_LightColor;

将物体原本颜色 * ambient 进行叠加，就能得到上面图片的结果。这时看起来物体是相当暗淡的。

### Ⅱ.漫反射光照

##### 1.什么是漫反射光照？

在现实世界中，大多数物体表面是非常粗糙的，光线照射在一个片段（很小的一个区域）上，会向几乎所有方向反射出同种强度的光线，称之为漫反射光线。

而在我们的渲染器中，漫反射光照就是模拟这一过程，代表的意义就是：



一个**片段**被某个**光源**照射时，应该反射出什么强度的光线？



##### 2.法向量

我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（更亮）。为了测量光线和片段的角度，我们使用一个叫做法向量(Normal Vector)的东西，它是垂直于片段表面的一个向量，这两个向量之间的角度很容易就能够通过点乘计算出来。

我们知道两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就应该越小。

**法向量**应当以数据的形式保存在每个顶点的布局中，

```
float vertices[] = {
	// 格式: Position (x, y, z), TexCoords (u, v)

	// 1. 前面 (Front Face) - Z = 0.5f
	// 位置				  // 纹理坐标	   // 法向量
	-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,  0.0f, 0.0f, 1.0f, // 0 左下
	 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,  0.0f, 0.0f, 1.0f, // 1 右下
	 0.5f,  0.5f,  0.5f,  1.0f, 1.0f,  0.0f, 0.0f, 1.0f, // 2 右上
	-0.5f,  0.5f,  0.5f,  0.0f, 1.0f,  0.0f, 0.0f, 1.0f, // 3 左上

	// 2. 右面 (Right Face) - X = 0.5f
	// 位置				  // 纹理坐标	   // 法向量
	 0.5f, -0.5f,  0.5f,  0.0f, 0.0f,  1.0f, 0.0f, 0.0f, // 4 左下 (对应前面的右下空间位置)
	 0.5f, -0.5f, -0.5f,  1.0f, 0.0f,  1.0f, 0.0f, 0.0f, // 5 右下
	 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,  1.0f, 0.0f, 0.0f, // 6 右上
	 0.5f,  0.5f,  0.5f,  0.0f, 1.0f,  1.0f, 0.0f, 0.0f, // 7 左上

	 // 3. 后面 (Back Face) - Z = -0.5f (注意：为了看纹理是正的，UV顺序做了调整)
	  // 位置			   // 纹理坐标	// 法向量
	  0.5f, -0.5f, -0.5f,  0.0f, 0.0f,  0.0f, 0.0f, -1.0f, // 8
	 -0.5f, -0.5f, -0.5f,  1.0f, 0.0f,  0.0f, 0.0f, -1.0f, // 9
	 -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,  0.0f, 0.0f, -1.0f, // 10
	  0.5f,  0.5f, -0.5f,  0.0f, 1.0f,  0.0f, 0.0f, -1.0f, // 11

	  // 4. 左面 (Left Face) - X = -0.5f
	   // 位置				// 纹理坐标	 // 法向量
	  -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,  -1.0f, 0.0f, 0.0f, // 12
	  -0.5f, -0.5f,  0.5f,  1.0f, 0.0f,  -1.0f, 0.0f, 0.0f, // 13
	  -0.5f,  0.5f,  0.5f,  1.0f, 1.0f,  -1.0f, 0.0f, 0.0f, // 14
	  -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,  -1.0f, 0.0f, 0.0f, // 15

	  // 5. 上面 (Top Face) - Y = 0.5f
	  // 位置				// 纹理坐标	 // 法向量
	  -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,  0.0f, 1.0f, 0.0f, // 16
	   0.5f,  0.5f,  0.5f,  1.0f, 0.0f,  0.0f, 1.0f, 0.0f, // 17
	   0.5f,  0.5f, -0.5f,  1.0f, 1.0f,  0.0f, 1.0f, 0.0f, // 18
	  -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,  0.0f, 1.0f, 0.0f, // 19

	  // 6. 下面 (Bottom Face) - Y = -0.5f
	  // 位置				// 纹理坐标	 // 法向量
	  -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,  0.0f, -1.0f, 0.0f, // 20
	   0.5f, -0.5f, -0.5f,  1.0f, 0.0f,  0.0f, -1.0f, 0.0f, // 21
	   0.5f, -0.5f,  0.5f,  1.0f, 1.0f,  0.0f, -1.0f, 0.0f, // 22
	  -0.5f, -0.5f,  0.5f,  0.0f, 1.0f,  0.0f, -1.0f, 0.0f, // 23
};
```



##### 3.漫反射光照的计算

过程如下：

```
// 漫反射
vec3 norm = normalize(v_Normal);
vec3 lightDir = normalize(u_LightPosition - v_FragPos);
float diff = max(dot(norm, lightDir), 0.0);
vec4 diffuse = vec4(vec3(diff), 1.0) * u_LightColor;
```

###### ①首先归一化从顶点数据vertices传入的法向量数据v_Normal；

###### ②之后计算光照向量，从**光源点**到某个**片段的位置坐标**，并归一化；

这个v_FragPos来自于我们在shader内计算的世界坐标系中物体的所有顶点位置：

```
v_FragPos = vec3(model * vec4(position, 1.0));
```

这个 v_FragPos 其实类似于通过纹理的纹理坐标把纹理图片拉伸适配到物体上，然后在着色器自动获取整个物体上每一个片段应当对应纹理的哪一部分像素颜色的过程；v_FragPos 本身表示物体每个顶点的位置坐标，但之后shader可以自动计算物体的顶点之间任何片段的位置坐标。

实际这类过程就是图形渲染管线的核心机制：**光栅化插值**。

在顶点着色器（Vertex Shader）中，我们确实只计算了某个三角形三个顶点的 `v_FragPos`（世界坐标）。但是，当 GPU 把三角形画在屏幕上时，它会经过**光栅化（Rasterization）阶段。在这个阶段，GPU 会根据当前像素（Fragment）在三角形内部的相对位置，自动依据三个顶点的 v_FragPos 进行线性插值（Linear Interpolation）**。对于纹理和这里的片段位置坐标来说，都是这个原理。

###### ③通过光线向量和法向量点积，计算出夹角，diff就表示此时反射光的光线强度系数；

这里的点积 `dot(norm, lightDir)` 计算出的结果是：两个向量夹角的余弦 cos(θ)。那么为什么是余弦值？

因为点积数学公式是： `dot(A, B)`  = |A| * |B| * cos(A, B);

因为代码前面已经做了归一化（normalize），所以 norm 和 lightDir 的长度（模）都是 1。

于是公式变成了：1 * 1 * cos(θ);

代码中max()是为了限制结果最小为0，即光线与法向量垂直的时候，实际意义就是光线与片段所在平面平行，没有光照效果。

###### ④强度系数diff进一步叠加光照颜色，就是最终的漫反射光照效果。

之后，将效果值diffuse叠加到输出上即可：

```
FinalColor = mixedTexture * (ambient + diffuse);
```

##### 4.法向量矩阵：

我们发现，写定的法向量数据是基于物体的局部坐标系的，当物体在世界坐标系进行平移、旋转或缩放时，法向量就失效了。

这时，我们首先考虑到将model矩阵之接乘以我们的法向量数据，不就能把它们转换到世界坐标系了吗？

但实际上，我们的model包含平移&旋转&缩放三部分，其中缩放部分可能存在一种特殊情况：非均匀缩放（比如只把 x 轴拉长，y 轴不变），直接使用 Model 矩阵会导致法线不再垂直于表面。



因此我们使用：**逆矩阵的转置（Inverse Transpose）**

```
mat3 normalMatrix = transpose(inverse(mat3(model)));
```

简单来说，这行代码的作用是**为了消除“非均匀缩放”（Non-uniform scaling）对法线方向造成的扭曲**。

我们分两步来拆解：**操作步骤** 和 **数学原理**。

######  代码是如何操作 Model 矩阵的？

```
mat3 normalMatrix = transpose(inverse(mat3(model)));
```

这行代码从内向外执行了三个步骤：

1. **mat3(model) —— 裁剪位移**
   - `model` 是一个 4x4 矩阵，包含了位移（Translation）、旋转（Rotation）和缩放（Scale）。
   - 法线是一个**方向向量**，不是位置点。物体移动到哪里（位移），它的朝向（法线）是不会变的。
   - 因此，我们要把 4x4 矩阵左上角的 3x3 部分截取出来，这就丢弃了第 4 列的位移数据，只保留旋转和缩放信息。
2. **inverse(...) —— 求逆矩阵**
   - 计算该 3x3 矩阵的逆矩阵。逆矩阵代表了变换的“反向操作”。
3. **transpose(...) —— 求转置矩阵**
   - 将逆矩阵的行和列互换（沿着对角线翻转）。
   - **最终结果**：你就得到了所谓的“法线矩阵（Normal Matrix）”。

![屏幕截图 2025-12-06 140247](images\屏幕截图 2025-12-06 140247.png)

### Ⅲ.镜面反射光照

##### 1.什么是镜面反射光照？

在现实世界中，由于一些物体表面的特殊性质，光线照射在一个片段上时，会向入射角以法向量对称的方向附近反射出强度更大的光线，称之为镜面反射光线，即我们所说的高光。

而在我们的渲染器中，镜面反射光照就是模拟这一过程，代表的意义就是：



一个**片段**被某个**光源**照射时，现在的**视角**应该收到什么强度的光线？



##### 2.镜面反射光照的计算

过程如下：

```
// 镜面反射
    float specularStrength = 0.5; // 镜面反射系数
    vec3 viewDir = normalize(u_ViewPosition - v_FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec4 specular = vec4(vec3(specularStrength * spec), 1.0) * u_LightColor;
```

###### ①设置一个镜面反射系数；

###### ②计算视线向量，即照射点fragPos至视点view；

###### ③计算光线反射向量

`reflect` 是 GLSL（OpenGL着色语言）的内置函数，用于计算**反射向量**。

**参数解析**：函数原型是 `reflect(I, N)`。

- **I (Incident)**: 入射向量。**注意：** 它的方向必须是**指向表面**的。
- **N (Normal)**: 法线向量。必须是归一化的。

**为什么是 `-lightDir`？**

在你的代码中，`u_LightPosition - v_FragPos` 计算出的 `lightDir` 是**从物体指向光源**的（这是为了方便计算漫反射 Diffuse，法向量指向平面外部，点积结果是正数）。 但是，反射的物理定义中，光线是从光源**射入**表面的。 所以，我们需要把 `lightDir` 取反（`-lightDir`），让箭头**指向物体表面**，这样才能正确计算出光线弹射出去的方向 `reflectDir`。

###### ④求视线与反射光线的点积（夹角决定系数）

pow()进行幂运算，点积的32次幂，这里的32就是**反光度**

第一步：`dot(viewDir, reflectDir)`

这个点积计算的是 **“你的视线”** 和 **“光线的反射方向”** 有多接近。

- 结果为 1.0：你的眼睛正对着反射光（类似于被镜子反光晃瞎了眼），最亮。
- 结果为 0.0：你看的角度和反射光成 90 度，完全没看到高光。

第二步：为什么要 `pow`（幂运算）？

如果只用点积（相当于 1 次方），高光会非常大且边缘模糊。

因为余弦函数（dot 的结果）在 0 到 90 度之间下降得很慢。如果直接输出，物体看起来会像橡胶或者粗糙的塑料，只有一种“油腻”的泛光，而不是锐利的高光。

我们希望模拟**金属**或**抛光表面**：只有当视线**非常接近**反射方向时，才能看到亮斑；稍微偏一点，亮度就急剧下降。

幂运算的作用就是“聚焦”高光：

我们来看数学性质（假设底数是 0.9，表示你的眼睛稍微偏离了一点点反射光）：

- **1 次方（不加 pow）**：0.9^1 = 0.9 —— 还是很亮。
- **32 次方**：0.9^32 = 0.034 —— **亮度直接几乎归零了！**
- **只有当底数极度接近 1 时（比如 0.99），32次方的值才能保持较大 (0.99^32 = 0.72)。**

也就是说高光会更加集中在反射光线附近相当小的范围内！

![basic_lighting_specular_shininess](images\basic_lighting_specular_shininess.png)

###### ⑤将强度系数spec与镜面反射系数specularStrength相乘，得到最终的强度系数，之后叠加光照颜色，就是最终的镜面反射效果了。

之后类似与漫反射，将镜面反射效果也叠加到物体上面：

```
FinalColor = mixedTexture * (ambient + diffuse + specular);
```

![屏幕截图 2025-12-06 140131](images\屏幕截图 2025-12-06 140131.png)



## 三、效果

<video src="videos\屏幕录制 2025-12-06 183615.mp4"></video>