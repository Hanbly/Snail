# 12.22后处理边缘



> 注：本文写于2026.1.6，与12.22仓库有所不同



## 一、回想之前我们的物体轮廓是如何实现的？

我们利用的OpenGL的模板测试，我的理解是：模板测试就是一个缓冲区（二维数组），可以把它理解成屏幕平面。

当我们开启模板测试时，任何绘制行为都会在模板测试缓冲区中留下痕迹，其内容就是0或1，我们可以变更其含义，比如让1表示我们绘制的部分，其余部分就都是0，反之亦然。

然后，在下一帧绘制时，我们额外绘制一次模板测试的内容，因为它已经记录了上一帧某个或某些物体的像素点位置，所以现在我们可以把这些数据稍微扩大一些，然后禁用深度测试并绘制，这样它就能绘制在原本的物体之上，但是由于深度测试不通过，同时我们禁用模板测试中我们绘制部分像素（的绘制），这样就只有被扩展的那一小部分像素显示在物体附近，看起来就像是边缘。

## 二、模板测试局限性

**首先**，模板测试需要两次绘制，这个重复绘制的不仅仅是外部一圈轮廓，而是比原先物体还要大一点的整个模型，即指令

RendererCommand::DrawIndexed(mesh.GetVAO());

所以如果物体的顶点越多，模板测试的开销就越大，我实际在高模中使用会明显看到帧率立刻下降。

**其二**，模板测试的边缘粗细会受到相机透视变化的影响，因为它本质是物体副本的一部分，所以相机变化时边缘的粗细就时粗时细，离远了看不清，离近了过于粗。

## 三、后处理边缘

我对后处理边缘的理解：

1.正常绘制过程时，利用FrameBuferr充当模板测试缓冲区的角色，绘制某个或某些物体时，在FBO中记录下它们的像素点（还是用0/1或类似的int值来表示）；

2.后处理阶段，再次开启FBO，依据已有的像素点信息，在一个特殊shader中根据一些规则判断0与1的边界，直接绘制轮廓，而非绘制整个物体再扣掉中心像素点。

### 具体实现细节

#### 1.u_EntityID的传递和使用

这涉及到shader的一些工作模式。

u_EntityID是一个统一变量，这个命名不太直观，在cpp代码中我叫它edgeEnable，也就是否绘制边缘，它是一个整数int。

在shader中，顶点着色器接收一个u_EntityID，并赋值给传递变量v_EntityID，片段着色器再接收v_EntityID，并把它输出到EntityIDBuffer：

```
layout(location = 1) out int EntityIDBuffer;

void main(){
	EntityIDBuffer = v_EntityID;
}
```

我的理解，这实际上可以看作是一个绘制的过程，只不过正常绘制是：

```
layout(location = 0) out vec4 FinalColor;

void main(){
	FinalColor = vec4(result, 1.0);
}
```

所以，当我们执行第一次绘制时，就能顺便把EntityID的信息绘制倒FBO的另一个颜色附件中（R32I单通道）。

#### 2.post_process_outline.glsl

我们绘制在屏幕上，所以顶点着色器比较简单，绘制一个矩形

```
layout (location = 0) in vec2 a_Pos;
layout (location = 1) in vec2 a_TexCoords;
out vec2 v_TexCoords;
void main() {
    v_TexCoords = a_TexCoords;
    gl_Position = vec4(a_Pos.x, a_Pos.y, 0.0, 1.0); 
}
```

而片段着色器中，我们先使用u_MaskTexture（之前的EntityID的信息）判断当前片段是否是EntityID为1的情况，是1直接丢弃，因为这代表这个片段是选中的物体，不绘制边缘：

```
int centerMask = texture(u_MaskTexture, v_TexCoords).r;
if (centerMask == 1) discard;
```

再依据边缘宽度、绘制矩形的长宽，计算出一个临近的片段，判断它是否属于选中物体，如果是选中物体，说明当前片段就是边缘（至少处在边缘的位置）；

下一步使用之前FBO的另外一个深度附件的传入，它的作用是计算当前片段和临近片段的深度值，如果当前片段的深度值更小（离相机更近），说明当前片段在空间中不处于物体附近，也就不是物体的边缘，一般来说就是遮挡物，所以取消绘制边缘：

```
// 获取线性深度 (单位：米/Unit)
float rawCenterDepth = texture(u_DepthTexture, v_TexCoords).r;
float linearCenterDepth = LinearizeDepth(rawCenterDepth);

vec2 texelSize = vec2(1.0 / u_Width, 1.0 / u_Height);
bool isEdge = false;

for (int x = -u_OutlineWidth; x <= u_OutlineWidth; ++x) 
{
    for (int y = -u_OutlineWidth; y <= u_OutlineWidth; ++y) 
    {
        if (x==0 && y==0) continue;

        vec2 uv = v_TexCoords + vec2(x, y) * texelSize;
        int neighborMask = texture(u_MaskTexture, uv).r;

        if (neighborMask == 1) 
        {
            float rawNeighborDepth = texture(u_DepthTexture, uv).r;
            float linearNeighborDepth = LinearizeDepth(rawNeighborDepth);
            
            // 情况 1: Center是前面的遮挡物片段
            // linearCenterDepth (10米) < linearNeighborDepth (20米)
            // -> 不画线
            
            // 情况 2: Center是后面的墙/背景片段
            // linearCenterDepth (50米) > linearNeighborDepth (20米)
            // -> 画线
            
            // 情况 3: Center是物体脚下的地面 (深度非常接近)片段
            // -> 画线
            
            // 所以：只有当 center >= neighbor (减去一个线性容差) 时才画
            // 这里的 0.1 代表 0.1 个单位距离，比 raw depth 的 0.0001 靠谱得多
            if (linearCenterDepth >= (linearNeighborDepth - 0.1)) {
                isEdge = true;
                break;
            }
        }
    }
    if (isEdge) break;
}

if (isEdge) FragColor = vec4(u_OutlineColor, 1.0);
else discard;
```

