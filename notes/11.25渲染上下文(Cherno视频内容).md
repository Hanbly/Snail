# 11.25渲染上下文(Cherno视频内容)

> ## 1.渲染上下文的理解 

**渲染上下文RenderContext的结构：**

抽象一个上下文类，它的派生类例如opengl上下文或vulkan上下文提供实现

**渲染上下文作为静态变量还是成员，归属于什么？**

理论上认为每个窗口含有一个渲染上下文，且仅有一个，所以目前由窗口持有一个唯一的成员m_RenderContext。个人理解：m_RenderContext不应该是静态的，如果是则后期无法支持多窗口，理论上每个窗口应该含有一个渲染上下文，即窗口对象拥有渲染上下文，而不是窗口类本身。

> ## 2.如何抽象渲染上下文  

目前代码中的WindowsWindow类进行了OpenGL的上下文定义：

```
/* Make the window's context current */
glfwMakeContextCurrent(m_Window);

// 初始化glad
if (!s_GLADInitialized) {
    int status = gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
    SNL_CORE_ASSERT(status, "GLAD初始化失败!");
    s_GLADInitialized = true;
}
```

我们需要把这些glfw相关代码全部抽象出去（因为这里是使用glfw特化使用OpenGL的，并非通用代码）

```
class SNAIL_API RenderContext {
protected:
	virtual void InitContextImpl() = 0;
	virtual void SwapBuffersImpl() = 0;
public:
	inline void InitContext() { this->InitContextImpl(); }
	inline void SwapBuffers() { this->SwapBuffersImpl(); }
};
```

```
class OpenGLRenderContext :	public RenderContext
{
private:
	GLFWwindow* m_WindowHandle;
	static bool s_GLADInitialized;
public:
	OpenGLRenderContext(GLFWwindow* window);
	~OpenGLRenderContext();
	virtual void InitContextImpl() override;
	virtual void SwapBuffersImpl() override;
};
```

具体实现把 **glfwMakeContextCurrent()** 与 **gladLoadGLLoader()** 写在InitContextImpl之中，**glfwSwapBuffers()** 写在SwapBuffersImpl之中。

之后在WindowsWindow中简单地替换调用，这些就是Cherno的视频内容。



在下一节笔记，我会介绍我个人基于cherno所介绍的**Renderer与RenderAPI**两者的关系，进行进一步的**代码结构构造**，我也说不上是不是一种优化，大概是：使用新的Renderer类包装**RenderAPI**中的内容，包括**RenderContext**类，也包括以后将创建的类，但是Renderer不再是一种抽象类或基类，从而在派生类实现不同的代码，而是在需要的方法中接收对应api或平台的枚举类型作为参数，再在内部分支依据不同的枚举类型调用不同的RenderAPI。