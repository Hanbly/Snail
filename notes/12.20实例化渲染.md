# 12.20实例化渲染

实例化渲染即批量渲染

在之前，我们的逻辑是每一帧提交一次渲染请求 DrawCall ，每次把需要绘制的数据独立提交给GPU，这会产生大量的交互成本，并且实际上OpenGL每次绘制的准备工作都是比较耗时间的。

导致的问题就是在绘制大量相同物体时，CPU忙不过来，在不停地发送请求一个又一个请求，但实际GPU的显存并没有充分利用。

如果我们能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。

## 如何创建实例化

一个实例化对象是什么？其实就是大量相同的模型（包含的是同一组顶点数据），但是进行的是不同的世界空间变换所组成的一系列模型集合。

> 其实有点像我们的 model对象 & entity实体 的关系
>
> model引用是共享的，但是每个实体都是我们实际看到的物体

所以我们定义：

```
struct InstanceData {
	glm::mat4 ModelMatrix;
	glm::mat3 NormalMatrix;
};
```

这个结构体包含每个不同的实体entity所对应的不同的 **transform矩阵** 和 **法线矩阵**（用于计算光照）。



**这些数据以往我们是如何持有使用的？**对于transform矩阵，我们是直接作为uniform独立上传，因为是每个物体单独渲染；对于法线矩阵，我们在CPU端计算后也是作为uniform上传。

但是现在不同了，因为如果浓缩成一次绘制，一个transform矩阵或一个法线矩阵肯定是不够的，不同的实体位置不同、旋转不同，数据必然不同，这就要我们创建一个新的VBO集成到原有的VAO之上：

```
Refptr<VertexBuffer> InstanceVBO;
```

```
// 创建实例 VBO，大小为 
// MaxInstances * (sizeof(glm::mat4) + sizeof(glm::mat3))
s_3DSceneData.InstanceVBO = VertexBuffer::Create(MAX_INSTANCES_PER_BATCH * sizeof(InstanceData));
// 设置布局
s_3DSceneData.InstanceVBO->SetLayout(BufferLayout::Create({ 
	{ "a_Model", VertexDataType::Mat4 },
	{ "a_NormalMatrix", VertexDataType::Mat3 } // 法线矩阵
	}));
```

这里在VertexBuffer::Create中，我们使用：

```
glBufferData(GL_ARRAY_BUFFER, size, nullptr, GL_DYNAMIC_DRAW);
```

不立即传入数据，而是表明要动态设置。



创建后，我们在Renderer3D::FlushMeshes方法中计算完整的实例数据，

```
// -------- 计算实例数据 -------------
s_InstanceBufferData.clear();
s_InstanceBufferData.reserve(transforms.size());

for (const auto& transform : transforms)
{
	InstanceData data;				
	data.ModelMatrix = transform;
	// --- 检查矩阵是不是等比缩放 ---
	float sx2 = glm::length2(glm::vec3(transform[0]));
	float sy2 = glm::length2(glm::vec3(transform[1]));
	float sz2 = glm::length2(glm::vec3(transform[2]));
	// 允许一点点误差
	bool isUniform = glm::abs(sx2 - sy2) < 1e-4 && glm::abs(sy2 - sz2) < 1e-4;
	if (isUniform) { // 如果是统一缩放（或者没有缩放），直接取 3x3
		data.NormalMatrix = glm::mat3(transform);
	}
	else { // 需要求逆转置
		data.NormalMatrix = glm::transpose(glm::inverse(glm::mat3(transform)));
	}
	data.NormalMatrix = glm::transpose(glm::inverse(glm::mat3(transform)));

	s_InstanceBufferData.push_back(data);
}
```

之后上传数据：

```
// 上传 ModelMatrix + NormalMatrix
uint32_t dataSize = (uint32_t)s_InstanceBufferData.size() * sizeof(InstanceData);
s_3DSceneData.InstanceVBO->SetData(s_InstanceBufferData.data(), dataSize);
```

其中SetData调用的是：

```
glBufferSubData(GL_ARRAY_BUFFER, 0, size, data);
```

允许我们向缓冲区上传部分数据。



最后绑定到已有VAO上并绘制：

```
// 绑定 Mesh 的 VAO 并挂载 Instance Buffer
auto vao = mesh->GetVAO();
vao->Bind();

// 这一步将 InstanceVBO 绑定到该 VAO 的属性位置上 (例如 location 3,4,5,6)
vao->SetInstanceBuffer(s_3DSceneData.InstanceVBO);

// 4. 执行实例化绘制命令
RendererCommand::DrawIndexedInstanced(vao, (uint32_t)transforms.size());
```

其中SetInstanceBuffer在做的事情是 把新的transform矩阵以及法线矩阵的布局使用**glVertexAttribPointer**真正的设置到Layout中，由于这两部分的特殊性，我们不能使用已有的方法指定布局：

```
void OpenGLVertexArray::SetInstanceBuffer(const Refptr<VertexBuffer>& vertexBuffer)
{
	if (m_SettedInstanceBuffer) return;

	Bind();
	vertexBuffer->Bind();

	// 复用 m_VertexBufferIndexOffset，这样实例属性的 index 会紧接在顶点属性之后
	// 例如：Pos(0), Normal(1), Tex(2) -> ModelMatrix 会从 3 开始
	uint32_t& index = m_VertexBufferIndexOffset;

	auto& layout = vertexBuffer->GetLayout();
	auto& elements = layout->GetLayoutElements();

	for (const auto& element : elements)
	{
		// 这里的逻辑需要特殊处理 Matrix 类型
		// OpenGL 中 mat4 实际上占用 4 个连续的 vec4 属性位置
		if (element.type == VertexDataType::Mat4) {
			uint8_t count = 4; // mat4 有 4 列
			for (uint8_t i = 0; i < count; i++)
			{
				glEnableVertexAttribArray(index);
				glVertexAttribPointer(
					index,
					4, // 每一列是 vec4，也就是4个float
					GL_FLOAT,
					element.enableNormalize ? GL_TRUE : GL_FALSE,
					layout->GetLayoutSize(),
					(const void*)(element.offset + sizeof(float) * 4 * i)
				);
				// 关键点：设置属性除数为 1，表示每 1 个实例更新一次数据
				glVertexAttribDivisor(index, 1);
				index++;
			}
		}
		else if (element.type == VertexDataType::Mat3) {
			uint8_t count = 3; // mat3 有 3 列
			for (uint8_t i = 0; i < count; i++)
			{
				glEnableVertexAttribArray(index);
				glVertexAttribPointer(
					index,
					3, // 注意：这里是 3 (vec3)
					GL_FLOAT,
					element.enableNormalize ? GL_TRUE : GL_FALSE,
					layout->GetLayoutSize(),
					// 偏移量计算：基础偏移 + 第 i 列 * 每列 3 个 float * float大小
					(const void*)(element.offset + sizeof(float) * 3 * i)
				);
				glVertexAttribDivisor(index, 1);
				index++;
			}
		}
		else {
			glEnableVertexAttribArray(index);
			glVertexAttribPointer(
				index,
				element.GetComponentCount(),
				GetOpenGLType(element.type),
				element.enableNormalize ? GL_TRUE : GL_FALSE,
				layout->GetLayoutSize(),
				(const void*)(uintptr_t)element.offset
			);
			glVertexAttribDivisor(index, 1);
			index++;
		}
		m_SettedInstanceBuffer = true;
	}
}
```

这里的关键点有两个：

①不使用element.GetComponentCount()，因为这个获取的是mat4的真正数量即16，而我们在这里指定布局时，必须按照**四个vec4**的逻辑来循环四次指定，这是OpenGL的问题，4就是它的上限；

②额外使用glVertexAttribDivisor(index, 1);来告诉OpenGL这个是一个实例化对象的布局，应该每个实例（也就是大量相同的mesh为一组）更新一次布局，而不设置时会每个mesh更新一次。这就是每次能够渲染多个物体的缘由。index是布局的id，1是属性除数，默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推。



最后我们需要在顶点着色器中再添加2个顶点属性：

```
// mat4 自动占用 location 3, 4, 5, 6
layout(location = 3) in mat4 a_Model; 
// 法线矩阵 (loc 7,8,9)
layout(location = 7) in mat3 a_NormalMatrix;
```

```
vec4 worldPos = a_Model * vec4(position, 1.0);

v_Normal = normalize(a_NormalMatrix * a_Normal);
v_FragPos = vec3(worldPos);
v_TextureCoords = TextureCoords;

gl_Position = u_ViewProjection * worldPos;
```

