# 1.5FrameBuffer重构 & 单光源阴影映射

在之前进行的HDR等距柱状图加载，以及后处理Gamma校正时，我们的FBO都必须使用RGBA16F 以及 GL_FLOAT 这种数据类型；

在之前，我们的FrameBuffer类是硬编码的，直接使用的是RGBA8 和 BYTE 类型，

并且，ReGenerate方法会直接创建所有的附件类型，一个颜色附件，一个Mask附件（接收物体轮廓int），一个深度附件，

并且，颜色附件和Mask是写死索引的，颜色附件对应0，Mask对应1，只支持一个颜色附件。

基于以上问题，我重构了 FrameBuffer 类。

## 一、FrameBuffer重构

我们的任务是：

1.支持更多附件数据类型

2.支持自定义创建附件

3.支持多颜色附件

格式枚举

```
enum class FrameBufferTextureFormat {
	None,
	R32I, RGB8, RGBA8, RGBA16F, RGBA32F,
	DEPTH_COMPONENT, DEPTH24_STENCIL8
};
```

spec添加附件的Specification列表，目前只含有TextureFormat，即格式列表，对应的就是所有的附件列表

```
struct FrameBufferSpecification {
	uint32_t width, height;
	std::vector<FrameBufferAttachmentSpecification> attachments;

	bool SwapChainTarget = false;

	FrameBufferSpecification(const uint32_t& width, const uint32_t& height)
		: width(width), height(height)
	{
	}
};
```

如此，在创建spec时，就可以

```
FrameBufferSpecification spec(1920, 1080);

spec.width = 1920, spec.height = 1080;
spec.attachments = {
	FrameBufferTextureFormat::RGBA32F,
	FrameBufferTextureFormat::R32I,
	FrameBufferTextureFormat::DEPTH24_STENCIL8
};
m_TempFBO = FrameBuffer::Create(spec);
```

表示这个FBO有一个RGBA32F颜色附件，一个R32I颜色附件，一个DEPTH24_STENCIL8深度附件。

在真正创建附件时，也只需要遍历spec.attachments，并依据附件类型，设置对应的各种格式即可，最终创建；

目前颜色附件是附件列表，所以使用一个TempId来创建，最后push进入列表中，而深度附件直接使用成员m_DepthAttachment来创建即可。

## 二、阴影映射

单光源阴影映射的实现是基于深度贴图的。

这里的深度贴图是以某个光源的视角，去观察整个场景，对于平行光来说，这个视角就是 view\*ortho，对于点光源来说就是 view\*perspective，即正交投影还是透视投影的区别；

然后，我们把这个视角的场景绘制到一个FBO中，不绘制色彩，而只绘制深度，得到一张光照空间的深度贴图，也叫阴影贴图；

但是只有深度图是无法绘制相机视角的阴影如何显示的，因为我们只知道光源能不能照射到某个点，但不知道这个点如何转换到相机视角，所以还是需要之前的光源空间矩阵 view\*ortho 或  view\*perspective ；

ShadowMap 和 光源空间矩阵 这两部分就能在shader中经过一些方法，计算出当前片段是否处于阴影中，如果是，就会将此时的整体光照影响中的漫反射和镜面反射的效果进行一些弱化。

### 实现

其实现我们依旧使用FBO，但是这时不能使用之前的TempFBO了，因为我们要做两次完整的绘制，第一次依据光源空间绘制阴影贴图，第二次要依据阴影贴图和光源空间来绘制场景，我们没办法绘制阴影贴图的同时使用阴影贴图，同一个FBO也无法承接不同视角的两次绘制（光源空间 & 相机视角）。

### shader

绘制阴影贴图的shader

```
#type vertex
#version 330 core
layout (location = 0) in vec3 a_Position; 
#ifdef INSTANCING
    layout(location = 3) in mat4 a_Model;
#else
    uniform mat4 u_Model;
#endif
uniform mat4 u_LightSpaceMatrix;
void main()
{
    mat4 modelMatrix;
    #ifdef INSTANCING
        modelMatrix = a_Model;
    #else
        modelMatrix = u_Model;
    #endif
    gl_Position = u_LightSpaceMatrix * modelMatrix * vec4(a_Position, 1.0);
}

#type fragment
#version 330 core
void main()
{
    // gl_FragDepth = gl_FragCoord.z;
}
```

仅仅是计算光源视角的gl_Position即可，因为绘制FBO的深度附件时会自动把深度值写入；

标准shader的变化

```
float ShadowCalculation(vec4 fragPosLightSpace, vec3 normal, vec3 lightDir)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    if(projCoords.z > 1.0)
        return 0.0;
        
    // 保留一个较小的值，因为绘制阴影贴图时使用了正面剔除
    // float bias = max(0.001 * (1.0 - dot(normal, lightDir)), 0.0001);
    float bias =0.0f;
    
    float shadow = 0.0;
    
    vec2 texelSize = 1.0 / vec2(textureSize(u_ShadowMap, 0));
    
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(u_ShadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += (projCoords.z - bias) > pcfDepth ? 1.0 : 0.0;
        }    
    }
    shadow /= 9.0;
    
    return shadow;
}
```

其中fragPosLightSpace是经光照空间矩阵计算后，当前片段在光照空间的位置坐标；

#### 1. 坐标转换：从齐次坐标到 NDC

```
vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
```

- **输入：** fragPosLightSpace 是当前片元经过 光照投影矩阵 * 光照视图矩阵 * 模型矩阵 变换后的坐标。此时它是齐次坐标（Homogeneous Coordinates）。
- **操作：** 透视除法（Perspective Divide）。将 xyz 除以 w。
- **结果：** 得到了 **NDC（标准化设备坐标）**。此时，projCoords 的 x, y, z 分量都在 [-1, 1] 的范围内。
  - xy 对应屏幕（光照视角）上的位置。
  - z 对应当前片元距离光源的深度。

#### 2. 坐标映射：从 NDC 到 纹理坐标

```
projCoords = projCoords * 0.5 + 0.5;
```

- **目的：** 深度贴图（u_ShadowMap）的纹理坐标范围是 [0, 1]，而深度值范围通常也是 [0, 1]。
- **操作：** 将 [-1, 1] 的 NDC 坐标线性映射到 [0, 1]。
  - x, y 变成了采样纹理的 UV 坐标。
  - z 变成了当前片元在光照空间下的深度值（[0, 1]）。

#### 3. 边界处理

```
if(projCoords.z > 1.0)
    return 0.0;
```

- **含义：** 如果当前片元的深度 z 大于 1.0，说明它超出了光源投影矩阵的**远平面（Far Plane）**。
- **作用：** 超出光照范围的物体通常不应该有阴影（或者被视为被照亮）。如果没有这一步，纹理采样的 GL_CLAMP_TO_EDGE 等设置可能会导致远处的物体错误地全部变黑。这里直接返回 0.0 表示“没有阴影”。

#### 4. 阴影偏移（Bias）与 正面剔除

```
// float bias = max(0.001 * (1.0 - dot(normal, lightDir)), 0.0001);
float bias = 0.0f;
```

- **背景知识（Shadow Acne）：** 传统的阴影映射由于分辨率限制，会导致物体表面出现条纹状的黑色噪点（阴影痤疮）。通常的做法是减去一个微小的 bias（偏移量）。
- **这里的做法：**
  - 代码注释掉了一段基于角度计算 bias 的经典算法。
  - 当前使用的是 bias = 0.0f。
  - **原因（注释中提到）：** 因为绘制阴影贴图时使用了正面剔除。
  - **原理解释：** 在生成阴影贴图（Shadow Map）的 Pass 中，开启**正面剔除（Front Face Culling）**，意味着只有物体的**背面**会被渲染进深度贴图。
  - 这样一来，深度贴图中记录的深度本身就比此时我们在渲染的“正面”要深一点（基于物体的厚度）。这天然地形成了一个 Bias，因此在计算阴影时就不需要额外减去 Bias 了，可以有效解决阴影痤疮问题，同时避免“彼得潘现象”（Peter Panning，即阴影与物体分离）。

#### 5. PCF 柔和阴影核心循环

这部分是实现软阴影的关键。如果不使用 PCF，阴影边缘会呈现明显的锯齿状（像素化）。

```
vec2 texelSize = 1.0 / vec2(textureSize(u_ShadowMap, 0));
```

- 计算**纹素大小（Texel Size）**。即阴影贴图中一个像素对应 u, v 坐标的大小。用于后续寻找相邻的像素。

```
for(int x = -1; x <= 1; ++x)
{
    for(int y = -1; y <= 1; ++y)
    {
        // ... 采样并累加 ...
    }    
}
```

- 这是一个 **3x3 的采样核**。它不仅检查当前像素，还检查周围一圈（共9个点）。

```
float pcfDepth = texture(u_ShadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
shadow += (projCoords.z - bias) > pcfDepth ? 1.0 : 0.0;
```

- **projCoords.xy + vec2(x, y) \* texelSize**：偏移采样坐标，获取周围像素的深度值。
- **pcfDepth**：从阴影贴图中读取的深度值（即：离光源最近的物体的深度）。
- **projCoords.z**：当前片元距离光源的深度。
- **比较逻辑：**
  - 如果 当前片元深度 > 贴图记录深度，说明当前片元被挡住了，**有阴影**（加 1.0）。
  - 否则，被照亮（加 0.0）。

#### 6. 平均化结果

```
shadow /= 9.0;
```

- 将累加的结果除以 9。
- **效果：** 结果 shadow 将是一个 0.0 到 1.0 之间的浮点数，而不是非黑即白的二值。
  - 例如：如果9个点中有4个在阴影里，结果就是 4/9。边缘会呈现灰色，从而视觉上看起来更柔和。