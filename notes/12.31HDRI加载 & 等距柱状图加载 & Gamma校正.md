# 12.31HDRI & 等距柱状图加载 & Gamma校正

## 一、HDRI

HDRI 即 High Dynamic Range Image。

在以往的Texture2D或Cube加载纹理时，我们都是使用的stb_image并且使用OpenGL中的RG8/RGB8/RGBA8等等作为颜色格式，GL_UNSIGNED_BYTE作为数据格式。因为普通LDR（Low Dynamic Range）资源的数据就是0-255的整数，只不过通道数有所差异；

而HDRI资源的数据是浮点数，我们要使用RGBA16F和GL_FLOAT这样的参数来生成纹理，所以本节涉及到纹理类的一次重构。

首先目前添加的HDRI包括.hdr与.exr，.hdr在stb_image中是支持的，直接使用之前的方法加载即可，但是.exr需要特殊处理，我们引入的库是 tinyexr，一个专门加载exr格式资源的轻量级库

```
if (extension == ".exr") {
	const char* err = nullptr;
	int ret = LoadEXR((float**)&data, &width, &height, path[0].c_str(), &err);

	if (ret != TINYEXR_SUCCESS) {
		if (err) {
			SNL_CORE_ERROR("TinyEXR 加载失败: 错误信息: {0}", err);
			FreeEXRErrorMessage(err);
		}
		else {
			SNL_CORE_ERROR("TinyEXR 加载失败: {0} (未知错误)", path[0]);
		}
		return;
	}
	// TinyEXR 加载的总是 RGBA float，除非特殊设置
	channels = 4;
	isFloat = true;

	// 反转y轴
	FlipFloatBufferVertically(static_cast<float*>(data), width, height, channels);
}
else {
	// 判断是否为 HDR (stbi 只支持 .hdr，不支持 .exr)
	if (stbi_is_hdr(path[0].c_str())) {
		// 加载为浮点数据
		data = stbi_loadf(path[0].c_str(), &width, &height, &channels, 0);
		isFloat = true;
	}
	else {
		// 普通 LDR 加载 (png, jpg)
		data = stbi_load(path[0].c_str(), &width, &height, &channels, 0);
		isFloat = false;
	}
	if (!data) {
		const char* reason = stbi_failure_reason();
		SNL_CORE_ERROR("OpenGLTexture2D: stbi_load 加载失败!\n路径: {0} \n错误信息: {1}", path[0], reason);
		return;
	}
}
```

## 二、等距柱状图

等距柱状图是什么？

等距柱状图是一张 长:宽 = 2:1 的图片，常用于天空盒资源。

### 加载方式

我们目前的TextureCube所加载的是六张正方形的图片，组成一个立方体贴图，那么要如何把一张图片分解成六张呢？这就是我最初的思路，我想把整个图片切割成六张，然后按照原有的方法进行纹理生成。

但是这种方法需要先加载原始HDRI，再把六张HDRI分别保存，再加载这六张HDRI，这是非常耗时间且不必要的；

真正合理的方法是：把原始HDRI加载后，利用FBO的一个很方便的功能——将FBO关联到立方体贴图的某一个面上，然后绘制，就能直接把数据绘制到立方体贴图的一个面上。

### 如何绘制

知道了利用FBO，我们可以把一些内容绘制在目标立方体贴图上，那重点就是如何根据一个2:1的图片，正确绘制出贴图六个的面。

#### 准备：

创建一个单位立方体，作为绘制对象。

一个空的 Cubemap 纹理（分配好内存）。

一个 FBO。

加载 2:1 的等距柱状图 (equirectangularMap)。

一个特殊的 Shader。

#### 绘制（执行6次）：

对应单位立方体的6个面（右、左、上、下、前、后）。

**FBO设置**：使用 glFramebufferTexture2D 将 FBO 的颜色附件绑定到当前 Cubemap 的特定面上 (例如 GL_TEXTURE_CUBE_MAP_POSITIVE_X)。

```
void OpenGLFrameBuffer::SetupTextureCubei(const int index, const uint32_t& rendererId)
{									glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + index, rendererId, 0);
}
```

**相机设置**：设置 view 矩阵，让虚拟相机位于 (0,0,0) 并看向对应的面（FOV必须是90度，长宽比1:1）。

**绘制**：绑定 Cube VAO，使用特殊 Shader 绘制。

#### shader

```
#type vertex
#version 330 core

layout (location = 0) in vec3 aPos;
out vec3 localPos;
uniform mat4 projection;
uniform mat4 view;
void main()
{
    localPos = aPos;  
    gl_Position = projection * view * vec4(localPos, 1.0);
}

#type fragment
#version 330 core

out vec4 FragColor;
in vec3 localPos;

uniform sampler2D equirectangularMap;

const vec2 invAtan = vec2(0.1591, 0.3183);
vec2 SampleSphericalMap(vec3 v)
{
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
    uv *= invAtan;
    uv += 0.5;
    return uv;
}

void main()
{		
    vec2 uv = SampleSphericalMap(normalize(localPos));
    vec3 color = texture(equirectangularMap, uv).rgb;
    FragColor = vec4(color, 1.0);
}

```

对等距柱状图的进一步理解：等距柱状图其实就是球面展开图的近似，可以把它理解成球面展开图。

当我们在等距柱状图中采样纹素的时候，其实做的是把它看作一整个球面，我们看向某个方向，然后看到了一个像素的颜色。

但是我们绘制的是单位立方体，并不是一个球，在每个立方体片段中，a_Position被传递进来，在原点为000的情况下，它就代表了片段的方向向量（世界笛卡尔坐标系）。

**我们绘制立方体来模拟球面，而只有球面uv才能对应等距柱状图（球面展开图）。**

那么当我们绘制立方体时如何去采样呢？答案是我们把片段的坐标传递到片段着色器中，当作片段的方向，然后将这个方向由笛卡尔坐标系转换成球面坐标系，这样得到对应的球面上的一个vec2 uv坐标；转换后，得到的uv其实就近似对应了我们的等距柱状图（球面展开图），所以进一步使用 texture(equirectangularMap, uv).rgb 就能获得最终的纹素颜色。

对于实现细节

```
vec2 SampleSphericalMap(vec3 v)
{
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
    uv *= invAtan;
    uv += 0.5;
    return uv;
}
```

![屏幕截图 2026-01-06 185123](images\屏幕截图 2026-01-06 185123.png)

## 三、Gamma校正

把Gamma校正放在这里一起说，是因为，引入它对于HDRI与LDR资源的加载是有一些影响的。

### Gamma校正含义

Gamma的由来是：
$$
亮度 = 电压^{Gamma}
$$
即Gamma作为幂指数影响显示的颜色。

所以显示器固有一个Gamma曲线

![gamma_correction_gamma_curves](images\gamma_correction_gamma_curves.png)

即CRT Gamma，这里的y坐标可以理解为颜色，比如(0.5,0.0,0.0)代表的是半暗红色。如果翻倍电压，它就会变成(1.0,0.0,0.0)，对应灰色虚线的样子；而Gamma曲线是非线性的，在中间调之间，gamma曲线上的颜色会显得暗一点。

而Gamma校正就是在抵消这种变化，我们对原始图片进行一个校正：
$$
校正 = 输入^\frac{1}{Gamma}
$$
这样图片会被先提亮一些，然后在显示器Gamma曲线的影响下，颜色就处于正确的线性空间了。

### 不同资源的Gamma校正

但是，资源并不能都进行Gamma校正，因为像png、jpg等这种LDR资源，其数据已经经过**sRGB (Gamma 0.45) 编码**了，即gamma校正过了，所以我们加载这些资源时，要先重新转换到线性空间；而HDRI则天生处于线性空间，它存储的是真实的物理色彩、亮度等；在最后，统一应用Gamma校正，再经历显示器的Gamma映射，这样最终的结果才是统一的线性的。

### HDRI的色调映射

对于HDRI，它直接存储物理辐射亮度值，原本就是线性的，但是它的值往往太大或太小了，显示器实际能够显示的还是0-1这个区间的值。

```
// ACES Tone Mapping 算法
vec3 ace_tone_mapping(vec3 x) {
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}
```

算法用来色调映射。它应该在gamma校正之前进行。

### 如何实现

我创建了一个TempFBO代替之前的FBO，在正常绘制时，进行写入，因为我们加入了HDRI，这个FBO的数据格式要符合RGBA16F以及GL_FLOAT；之后还有一个FinalFBO用于最后的输出，它的写入应该在绘制之后，我们的Gamma校正shader是独立的，只有在最后，FinalFBO使用校正shader来绘制一次屏幕，TempFBO则作为采样，这样整个场景只会被校正一次，校正的参数也好控制；

后处理物体轮廓是在Gamma校正之后进行的，直接使用FinalFBO，在其中额外绘制即可，不能先在TempFBO绘制，因为轮廓颜色会被色调映射以及Gamma校正，而产生偏差；而且也不必重新绘制一遍屏幕，因为轮廓只是判断边缘，并决定绘制与否，绘制也是直接覆盖原有像素即可。