# 12.19材质系统优化：全局资源缓存

为什么要做缓存？

当我们创建shader时，实际做的是读取特定路径下的shader代码，然后要进行shader代码的**规范化和编译&链接**，整个过程是耗时的；

对于texture也是一样，纹理创建不仅需要OpenGL的内存分配，最耗时的部分是读取纹理的资源，即贴图，这部分我们目前是通过stb_image来读取图片。

所以通过全局缓存，当试图创建新的shader或texture时，我们先检测是否存在于缓存，如果之前创建过就直接使用缓存中的资源引用。

## 实现

之前我们做过ShaderLibrary类，这个类就可以很好地充当全局缓存。

但是我们需要改造一下，首先要明确library类应该是一个完全的静态类，或者说是一个单例，运行的程序中只存在一个library类，通过ShaderLibrary::func来调用类的公有方法。

另外，之前我们在该类中的成员只有一个无序表：<命名，shader引用>，这种情况我们不能很方便地去检索某个shader的文件路径是否存在，因为要先通过命名遍历，再通过shader引用来调用获取路径的方法，这种遍历累积下来就会导致很大的性能损耗。

所以，得出改造的两个方向：①改造成静态类 ②分别添加命名缓存和路径缓存

我们重点说第二点：

创建的两个静态成员m_ShaderNames和m_ShaderPaths，分别缓存命名和路径：

static std::unordered_map<std::string, Refptr<Shader>> m_ShaderNames;
static std::unordered_map<std::string, Refptr<Shader>> m_ShaderPaths;

### 重点：Load方法

```
Refptr<Shader> ShaderLibrary::Load(const std::string& filePath)
{
	// 从路径提取名字 (例如 assets/shaders/Cube.glsl -> Cube)
	std::filesystem::path path = filePath;
	std::string name = path.stem().string();          // 除去扩展名的文件名

	std::string pathKey = PathsToKey(filePath);

	if (m_ShaderPaths.find(pathKey) != m_ShaderPaths.end()) { // 资源已经加载过
		if (m_ShaderNames.find(name) == m_ShaderNames.end()) { // 但是找不到对应命名
			m_ShaderNames[name] = m_ShaderPaths[pathKey]; // 把 pathKey 对应的着色器对象添加到命名映射表
		} // else 否则就是完全相同，不做操作
		return m_ShaderPaths[pathKey];
	}

	if (m_ShaderNames.find(name) != m_ShaderNames.end()) { // 命名已经存在
		SNL_CORE_WARN("ShaderLibrary: 名字 '{0}' 已被占用，但指向的是不同资源！", name); // 返回已有资源
		return m_ShaderNames[name];
	}

	const Refptr<Shader>& shader = Shader::Create(filePath);
	m_ShaderNames[name] = shader;
	m_ShaderPaths[pathKey] = shader;

	return shader;
}
```

load不再是原来简单的接收文件路径并创建一个shader，而是先要判重，逻辑如下：

- 获取shader的命名key，要么从文件路径提取，要么就直接使用参数之中的自定义命名；

  1.然后**首先判断文件路径**，也就是真正的资源路径，是否存在于**路径缓存**之中，因为我们真正想要的就是避免重复加载路径，如果资源相同，再去判断**命名缓存**；

- 如果资源路径存在，但命名缓存不存在命名，那么就把已有的路径缓存的shader引用和新的命名组成一个新的命名缓存，push进入命名缓存；

- 如果资源路径存在，且命名缓存存在命名，这种情况不需要做任何操作

  ------

  2.**判断文件路径**的else分支，即资源路径不存在，这时也要判断命名缓存，因为我们需要判断目前命名是否已经被创建过资源了；

- 如果资源路径不存在，而命名缓存存在命名，这种情况就要考虑到底是重新创建一个资源覆盖原有资源，还是保留原有资源，因为**命名冲突**了；这里我采用的是**保存原有资源**；
- 如果资源路径不存在，且命名缓存不存在命名，这种情况就是完全不同的资源，直接创建并缓存命名和路径。

## 值得一提

对于texturelibrary，跟shader是一模一样的，只不过，由于texture为了适配立方体贴图，它的资源路径是一个 vector<string>，这时就不太方便直接把texture的资源路径作为键来保存了，因为这种情况如果要对比键的话，就要循环遍历每个vector。

采用

```
std::string TextureLibrary::PathsToKey(const std::vector<std::string>& paths) {
	if (paths.size() == 1) return paths[0];
	std::string key;
	for (const auto& p : paths) key += p + ";";
	return key;
}
```

可以解决这个问题，这个辅助函数通过循环资源路径把整个vector组合起来作为键，之后进行

```
m_TexturePaths.find(pathKey) != m_TexturePaths.end()
```

> 当不存在的时候，无序表的find迭代器会移动到表尾，也就对应着m_TexturePaths.find(pathKey) == m_TexturePaths.end() 的情况