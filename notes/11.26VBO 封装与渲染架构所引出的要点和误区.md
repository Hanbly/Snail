# 11.26 VBO 封装与渲染架构所引出的要点和误区

## 1. 基础类型与标准库头文件

**核心要点**：uint32_t 等固定宽度整数类型并非 C++ 语言内置关键字，而是标准库定义的别名。在跨平台开发中，必须包含 <stdint.h> (C) 或 <cstdint> (C++) 才能使用，否则编译器无法识别。

```
// ❌ 直接使用 uint32_t 可能导致未定义标识符错误
uint32_t id;

// ✅ 引入标准头文件
#include <cstdint>
uint32_t id;
```

## 2. 抽象类实例化与静态工厂方法 (Static Factory Method)

**核心要点**：C++ 禁止直接实例化包含纯虚函数的抽象类（如基类 VertexBuffer）。在游戏引擎架构中，通常使用**静态工厂方法 (Create)** 来解决此问题。该方法根据当前的渲染 API（OpenGL/Vulkan/DirectX）动态创建并返回对应的子类实例，对上层隐藏具体实现细节。

```
// ❌ 错误：无法实例化抽象类
auto vbo = std::make_shared<VertexBuffer>(data, size);

// ✅ 正确：创建使用静态 Create 函数，内部判断 API 并返回子类 (OpenGLVertexBuffer)
// 在 Client 端：
std::shared_ptr<VertexBuffer> vbo = VertexBuffer::Create(data, size);

// 在 Engine 端实现：
std::shared_ptr<VertexBuffer> VertexBuffer::Create(float* vertices, uint32_t size) {
    switch (Renderer::GetAPI()) {
        case RenderAPI::OpenGL: return std::make_shared<OpenGLVertexBuffer>(vertices, size);
        // ... 其他 API
    }
    return nullptr;
}
```

## 4. shared_ptr 与渲染资源的所有权

**核心要点**：对于 VertexBuffer、Shader 等渲染资源，优先使用 std::shared_ptr 而非 std::unique_ptr。因为这些资源往往需要被多个对象持有（例如：一个 VBO 可能被多个 VAO 引用，或者被缓存系统管理）。使用 unique_ptr 会导致所有权移交后原指针失效，无法实现资源的复用。

```
// ❌ 限制：如果用 unique_ptr，添加到 VAO 后，m_VertexBuffer 就变成空指针了
std::unique_ptr<VertexBuffer> vbo = ...;
vao->AddVertexBuffer(std::move(vbo)); 

// ✅ 灵活：VAO 引用计数 +1，Application 层依然持有该指针，可继续修改数据
std::shared_ptr<VertexBuffer> vbo = VertexBuffer::Create(...);
vao->AddVertexBuffer(vbo);
```

## 5. 静态成员变量的链接错误 (LNK2001)

犯过多次这个错误了。

**核心要点**：在类中声明 static 成员变量（如 static RenderAPI s_RenderAPI）只是告诉编译器它的存在。必须在且只能在**一个 .cpp 源文件**中对其进行定义和初始化，否则链接器无法分配内存，会导致无法解析的外部符号错误。

```
// Renderer.h (声明)
class Renderer {
    static RenderAPI s_RenderAPI;
};

// Renderer.cpp (定义 - 必须有这一步！)
namespace Snail {
    RenderAPI Renderer::s_RenderAPI = RenderAPI::OpenGL;
}
```