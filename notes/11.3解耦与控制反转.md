- 
- 
- 
- 
- 









# 解耦与控制反转.



引擎Snail项目中（编译为dll）Snail/Snail/Application.h:#pragma once

\#include "Core.h"

namespace Snail {

```
class SNAIL_API Application
{
public:
	Application();
	// Application 类会被Example所继承，所以使用virtual
	virtual ~Application();

	void run();
};

// 将在客户端（子类中）给出函数体
Application* CreateApplication();
```

}

以及Snail/Snail.h:#pragma once

\#include "Snail/Application.h"

// 程序入口 -------------------------
\#include "Snail/EntryPoint.h"
//----------------------------------
以及Snail/Snail/EntryPoint.h:#pragma once

\#ifdef SNL_PLATFORM_WINDOWS

codeCode





```
extern Snail::Application* Snail::CreateApplication();

int main(int argc, char** argv)
{
	auto app = Snail::CreateApplication();
	app->run();
	delete app;
}
```

\#endif
以及Application的实现#include "Snail.h"

class Example : public Snail::Application {
public:
Example(){}
~Example(){}

};

Snail::Application* Snail::CreateApplication()
{
return new Example();
}我有几个问题：
1.为什么引用#include "Snail/EntryPoint.h"之前EntryPoint.h中报错识别不到Snail：：Application，引用即可识别。2.为什么在Application.h声明// 将在客户端（子类中）给出函数体
Application* CreateApplication();却不在对应.cpp定义，而是在实现子类中定义。3.extern Snail::Application* Snail::CreateApplication();作用是什么，为什么要这样写而不引用Application类？

![Thinking](https://www.gstatic.com/aistudio/watermark/watermark.png)

你好！这是一个非常好的问题，它触及了C++中引擎/框架设计的一个核心思想：**解耦（Decoupling）和控制反转（Inversion of Control）**。

你提供的代码片段是一个典型的游戏引擎框架结构，其中：

- Snail 项目是**引擎**（或框架），它被编译成一个库（DLL）。
- Example 类所在的那个项目是**客户端**（或应用程序），它使用 Snail 引擎。

让我们逐一解答你的问题。

### 总结：这套架构的核心思想

在深入细节之前，先理解整体设计：
引擎（Snail）提供了一套规则和基础（Application 类），但它不知道最终用户会创建什么样的具体应用（比如你的 Example 游戏）。为了解决这个问题，引擎定义了一个“约定”：**“任何使用我的人，都必须提供一个名为 CreateApplication 的函数，这个函数会返回一个具体的应用实例给我。”**

引擎的入口点 (main 函数) 就依赖这个约定。它不关心你返回的是 Example 还是 MyAwesomeGame，只要它是一个 Application 的子类，引擎就能通过 run() 方法让它运行起来。

------



### 问题1：为什么引用#include "Snail/EntryPoint.h"之前，EntryPoint.h中报错识别不到Snail::Application，引用即可识别？

这个问题的核心是 **C++ 编译器的“前向依赖”规则**。编译器在处理一个文件时，是从上到下逐行读取的。如果你使用了一个类型（比如 Snail::Application），那么在这个使用点之前，编译器必须已经知道这个类型的存在和定义。

让我们分析一下 Snail/Snail.h 的结构：

codeC++





```
// Snail.h

#pragma once

// 1. 首先包含 Application.h
#include "Snail/Application.h" 

// 2. 然后包含 EntryPoint.h
#include "Snail/EntryPoint.h"
```

- 当编译器处理 Snail.h 时，它首先会处理 #include "Snail/Application.h"。这时，Snail::Application 类的完整定义就被加载进来了。
- **然后**，编译器继续处理 #include "Snail/EntryPoint.h"。当它读到 EntryPoint.h 里的 Snail::Application* 时，它已经知道 Snail::Application 是什么了，所以编译通过。

**如果调换顺序**：

codeC++





```
// 错误的 Snail.h

#pragma once

// 1. 先包含 EntryPoint.h
#include "Snail/EntryPoint.h" // <-- 问题在这里

// 2. 后包含 Application.h
#include "Snail/Application.h"
```

- 编译器会先处理 EntryPoint.h。
- 当它看到 extern Snail::Application* Snail::CreateApplication(); 这一行时，它会问：“Snail::Application 是什么东西？” 因为此时 Application.h 还没有被包含进来，编译器不认识这个类型，所以就会报错。

**结论**：EntryPoint.h 的代码**依赖于** Application.h 中定义的类型。因此，包含头文件时必须保证被依赖的头文件（Application.h）在依赖方（EntryPoint.h）之前被包含。

------



### 问题2：为什么在Application.h声明 CreateApplication()，却不在对应.cpp定义，而是在实现子类中定义？

这是这个架构模式最精妙的地方，它实现了**引擎与客户端的解耦**。

1. **引擎的视角（Snail DLL）**：
   - 引擎提供了一个通用的 Application 基类。它知道应用程序需要一个入口，并且这个入口会创建一个 Application 实例。
   - 但是，引擎本身**不应该知道**任何具体的客户端实现（比如 Example 类）。如果引擎代码里出现了 new Example()，那么这个引擎就只能用于 Example 这一个项目了，失去了通用性。
   - 所以，引擎只**声明** Application* CreateApplication();。这相当于引擎立下了一个规矩：“嘿，使用我的客户端，你必须自己去实现这个函数，告诉我如何创建你的应用程序实例。”
2. **客户端的视角（Example 项目）**：
   - 客户端项目引用了 Snail 引擎。它创建了自己的 Example 类，继承自 Snail::Application。
   - 客户端**知道**如何创建自己的实例。所以，它负责**定义** CreateApplication() 函数，在函数体里返回 new Example()。
   - 这样，客户端就遵守了引擎定下的规矩。

**工作流程**：

1. 你编译 Snail 引擎，生成一个 Snail.dll。这个 DLL 里包含了 main 函数，但 CreateApplication 函数的实现是缺失的（因为它在客户端）。
2. 你编译 Example 项目，它会链接到 Snail.lib。你的项目里有 CreateApplication 的定义。
3. 当最终的可执行文件（.exe）被链接器生成时，链接器会把 Snail 引擎 main 函数中对 CreateApplication 的调用，和你在 Example 项目中提供的 CreateApplication 定义“链接”到一起。
4. 程序运行时，main 函数（来自引擎）调用 CreateApplication()，实际上执行的是你客户端代码里的版本，成功创建了 Example 对象。

**结论**：这种设计将“创建具体应用”的责任从引擎转移给了客户端，使得引擎可以保持通用和独立，而不需要为每一个使用它的游戏重新编译。这就是所谓的**控制反转**——通常是你的代码调用库，现在是库（引擎）在调用你的代码。

------



### 问题3：extern Snail::Application* Snail::CreateApplication(); 的作用是什么，为什么要这样写而不引用Application类？

extern 关键字在这里的作用是**纯粹的声明（Declaration）**。

1. **extern 的含义**：
   extern 告诉编译器：“我向你保证，这个函数（或变量）是真实存在的，但它的定义（函数体）在**另一个翻译单元**（通常是另一个 .cpp 文件或者一个库）中。你现在只需要知道它的签名（函数名、参数、返回值）就可以了，链接器（Linker）稍后会负责找到它的具体实现。”

2. **为什么在这里使用**：
   EntryPoint.h 文件中的 main 函数需要调用 Snail::CreateApplication()。为了能通过编译，编译器必须在调用点之前看到这个函数的声明。extern 就是这个声明。

3. **“为什么不引用Application类？”**
   这个问题可能有一点误解。这句话**确实引用了 Snail::Application 类**，因为它出现在返回值类型中 (Snail::Application*)。正如问题1所解释的，为了让编译器认识 Snail::Application，Application.h 必须在 EntryPoint.h 之前被包含。

   **那么，为什么不直接在EntryPoint.h里 #include "Application.h" 呢？**
   你完全可以这么做，这也是一种常见的做法：

   codeC++

   

   

   ```
   // EntryPoint.h (另一种写法)
   #pragma once
   
   #include "Application.h" // 直接包含头文件
   
   #ifdef SNL_PLATFORM_WINDOWS
   
       // extern 关键字现在是可选的，因为 Application.h 已经提供了函数声明
       extern Snail::Application* Snail::CreateApplication();
   
       int main(int argc, char** argv)
       {
           // ...
       }
   
   #endif
   ```

   实际上，Application.h 中已经有了 Application* CreateApplication(); 的声明，所以只要包含了 Application.h，extern 声明就变得多余了。

   **那为什么原作者要写 extern 呢？**

   - **明确性**：它非常明确地告诉阅读代码的人，这个函数的定义**一定**在外部。这是一种强调。
   - **最小化包含**：在一些大型项目中，为了加快编译速度，人们会尽量避免在头文件中包含其他头文件，而是使用前向声明（forward declaration）。虽然这里 extern 声明了一个函数而非类，但思想是类似的：只提供必要的最少信息。
   - **代码风格**：这可能就是作者的编码风格。

**总结**：extern 在这里的作用是向编译器提供 CreateApplication 函数的**前向声明**，告诉编译器这个函数的定义在别处。虽然因为 Snail.h 的包含顺序导致这个 extern 声明是多余的，但它的意图是清晰的：声明一个由外部（客户端）定义的函数。