# 12.11鼠标射线拾取

之前我们实现了外部模型加载，并且由ai写了一个点选imgui UI能够选取对应模型的示例，今天我们来创建鼠标射线拾取功能，这个功能涉及到很多算法，我目前也只是实现而已。

Snail项目目前把很多测试用例都写在了ExampleLayer里，这点以后需要完善，比如像cherno一样把编辑功能、docking停靠，也就是含有imgui相关面板的一系列编辑器，创建成新的项目。

## 1.鼠标射线

鼠标射线指由使用者在屏幕上点击的一个**鼠标坐标**，经过一系列转换而成的相对于世界坐标系的一个**射线向量**。

它包含一个起始点和一个方向。

glm::vec3 origin;    // 射线起点
glm::vec3 direction; // 射线方向（单位向量）

它的实际意义可以想象成：从**眼睛**出发，穿过**屏幕上一个点**，射向远方的一条线。

不要把屏幕上的鼠标坐标当作射线起点，它表示的是射线路径上的某个点。

## 2.鼠标射线的方法

鼠标射线应当由两个方法组成：一是鼠标射线如何从屏幕坐标变成一个射线向量；二是如何判断鼠标射线是否与某个模型相交。

### 构造方法MouseRay

```
MouseRay(const float& x, const float& y, const float& width, const float& height, const Refptr<PerspectiveCameraController>& cameraController)
{
    // 映射为 NDC 屏幕坐标：-1 ~ +1，经过矩阵转置的坐标结果就是NDC，现在要进行逆向操作
    float ndcX = (2.0f * x) / (float)width - 1.0f;
    float ndcY = 1.0f - (2.0f * y) / (float)height; // TODO: OpenGL的y轴反转，这里先这样写

    origin = cameraController->GetCamera()->GetCameraPos();
    // 必须 矩阵 * 向量
    glm::vec4 rayEye = glm::inverse(cameraController->GetCamera()->GetProjectionMatrix()) * glm::vec4(ndcX, ndcY, -1.0f, 1.0f);
    // 这一步决定了是在算“方向”
    rayEye = glm::vec4(rayEye.x, rayEye.y, -1.0f, 0.0f);
    glm::vec3 rayWorld = glm::vec3(glm::inverse(cameraController->GetCamera()->GetViewMatrix()) * rayEye);
    // 归一化
    direction = glm::normalize(rayWorld);
}
```

这里大概分为这几步：

###### ①鼠标坐标被映射为 NDC 屏幕坐标（-1到1的范围）

###### ②使用得到的矩阵进行投影逆向变换，得到eyeRay

这里是重点：-1.0f 代表近裁剪面（Near Plane），也就是屏幕平面本身；而1.0f用来构建齐次矩阵，跟平移的原理相似，投影矩阵的变换也需要其次矩阵。

###### ③继续进行视图逆向变换，得到worldRay

在第二步变换后，结果对应的eyeRay是近裁剪面（Near Plane）上的一个点其同时在鼠标射线上，这一步我们目的是得到它的方向，所以通过把w齐次改为0.0f是为了屏蔽相机的位移变换。

在世界坐标系，原点是00，经过视图矩阵变换后相机位置是00，如果不屏蔽相机位移，随着相机远离世界原点 `(0,0,0)`会产生射线偏移的效果：

![屏幕截图 2025-12-11 203551](images\屏幕截图 2025-12-11 203551.png)

###### ④归一化

### 相交判断bool Is_Cross

```
bool Is_Cross(const Refptr<ModelInstance>& model, float& outDistance)
{
    glm::vec3 localMin(std::numeric_limits<float>::max());
    glm::vec3 localMax(std::numeric_limits<float>::lowest());
    if (model->mesh) {
        localMin = model->mesh->m_MinVertex;
        localMax = model->mesh->m_MaxVertex;
    }
    else if (model->model) {
        const auto& meshes = model->model->GetMeshs();
        if (!meshes.empty()) {
            // 先以第一个网格作为基准
            localMin = meshes[0]->m_MinVertex;
            localMax = meshes[0]->m_MaxVertex;
            for (size_t i = 1; i < meshes.size(); i++) {
                localMin = glm::min(localMin, meshes[i]->m_MinVertex);
                localMax = glm::max(localMax, meshes[i]->m_MaxVertex);
            }
        }
    }

    // 2. 将局部 AABB 的 8 个角点变换到世界空间
    glm::mat4 transform = model->GetTransform();

    glm::vec3 corners[8];
    corners[0] = glm::vec3(localMin.x, localMin.y, localMin.z);
    corners[1] = glm::vec3(localMin.x, localMin.y, localMax.z);
    corners[2] = glm::vec3(localMin.x, localMax.y, localMin.z);
    corners[3] = glm::vec3(localMin.x, localMax.y, localMax.z);
    corners[4] = glm::vec3(localMax.x, localMin.y, localMin.z);
    corners[5] = glm::vec3(localMax.x, localMin.y, localMax.z);
    corners[6] = glm::vec3(localMax.x, localMax.y, localMin.z);
    corners[7] = glm::vec3(localMax.x, localMax.y, localMax.z);

    glm::vec3 worldMin(std::numeric_limits<float>::max());
    glm::vec3 worldMax(std::numeric_limits<float>::lowest());

    for (int i = 0; i < 8; i++) {
        // 变换点
        glm::vec4 transformed = transform * glm::vec4(corners[i], 1.0f);
        glm::vec3 p = glm::vec3(transformed); // / transformed.w; // 通常 w=1

        // 重新寻找新的 AABB 边界
        worldMin = glm::min(worldMin, p);
        worldMax = glm::max(worldMax, p);
    }

    // 3. Slab Method 检测算法
    float tmin = (worldMin.x - origin.x) / direction.x;
    float tmax = (worldMax.x - origin.x) / direction.x;

    if (tmin > tmax) std::swap(tmin, tmax);

    float tymin = (worldMin.y - origin.y) / direction.y;
    float tymax = (worldMax.y - origin.y) / direction.y;

    if (tymin > tymax) std::swap(tymin, tymax);

    if ((tmin > tymax) || (tymin > tmax))
        return false;

    if (tymin > tmin) tmin = tymin;
    if (tymax < tmax) tmax = tymax;

    float tzmin = (worldMin.z - origin.z) / direction.z;
    float tzmax = (worldMax.z - origin.z) / direction.z;

    if (tzmin > tzmax) std::swap(tzmin, tzmax);

    if ((tmin > tzmax) || (tzmin > tmax))
        return false;

    if (tzmin > tmin) tmin = tzmin;
    if (tzmax < tmax) tmax = tzmax;

    // tmin 是相交点距离相机的距离
    outDistance = tmin;

    // 如果 tmin < 0，说明物体在相机背后，但在射线直线上
    if (outDistance < 0) return false;

    return true;
}
```

#### AABB

AABB是一个包围着模型的长方体包围盒，它的所有边都是平行于三条轴的。

在模型和网格加载方法里，比较出顶点的“最小”和“最大”值，就是分别比较出最小的x最小的y最小的z，和最大的x、y、z，最终合并成两个虚拟的“最小”和“最大”顶点，然后靠这两个点就能得出一个包围着模型的框体。

#### Slab Method 检测算法

说实话这个我不太懂，也没细看算法，总之它的结果是得到射线与AABB包围盒距离最近的相交点的一个距离值，之后通过比较这个距离我们可以看到哪一个物体应该被选中。

## 3.通过上述方法“拾取”

所谓拾取就是点击模型然后可以选中，我们已经有了imgui的测试面板，现在应该添加一个鼠标按钮事件分发器，当鼠标左键按下时，先构造鼠标射线，然后遍历所有ModelInstance并计算最小距离，大概逻辑：

```
int hitIndex = -1;
float minDst = std::numeric_limits<float>::max(); // 记录最近的距离
for (int i = 0; i < m_Objs.size(); i++)
{
    float currentDst = 0.0f;
    // 传入引用获取距离
    if (ray.Is_Cross(m_Objs[i], currentDst))
    {
        // 寻找最近的物体 (处理遮挡)
        if (currentDst < minDst)
        {
            minDst = currentDst;
            hitIndex = i;
        }
    }
}
```

这样最终的hitIndex就是我们ModelInstance数组中当前被选中模型的索引了，如果点击空白部分，hitIndex就是一开始初始化的-1，表示没有物体被选择。