# 12.1实现相机的自由漫游

之前我们实现了相机的自由平移，经过本次研究后我们将解决两个问题：

1.相机平移的逻辑优化

2.实现相机的视角转动



## 一、相机平移的逻辑优化

之前我们的相机平移方法是通过计算相机坐标系的三个基向量，然后乘以移动速度

glm::vec3 frontdDir = glm::normalize(**m_Front** - m_Position);
glm::vec3 rightDir = glm::normalize(glm::cross(frontdDir, m_Up));
glm::vec3 upDir = glm::normalize(glm::cross(rightDir, frontdDir));

vector = frontdDir * length;

实际上这里存在一个误区：我认为m_Front 是相机盯住的一个坐标点，而非向量，这让我在后面使用欧拉角计算相机的旋转时吃了亏。

总之，这里优化的点在于

##### 1.front、right、up应该作为三个基向量被Camera类持有，特别是front并非相机的注视点。

##### 2.相机的上下移动不应该按照自身坐标系，而是直接使用世界坐标系的up基向量。



## 二、实现相机的视角旋转

本次笔记我使用的是欧拉角进行旋转，其本质是对向量front的空间旋转的计算。

### Ⅰ.欧拉角

#### 基于局部坐标系的旋转

![屏幕截图 2025-12-05 211415](images\屏幕截图 2025-12-05 211415.png)

#### 基于世界坐标系的旋转

![屏幕截图 2025-12-05 212458](images\屏幕截图 2025-12-05 212458.png)

这种是所谓的 **RPY (Roll-Pitch-Yaw)**，也是最符合直觉的。

我们的相机目前只需关注Pitch俯仰角和Yaw偏转角，分别绕我们世界坐标系的x轴和y轴旋转。

图来自 https://www.cnblogs.com/hysteresis/p/13892942.html

### Ⅱ.代码实现

**球坐标系转笛卡尔坐标系**

```
front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));
front.y = sin(glm::radians(pitch));
front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));
```

这段代码并没有显式地写出 旋转矩阵，而是**直接计算出了旋转后的结果向量**。

它的物理意义是：

假设摄像机原本指向初始方向（比如正X轴或负Z轴），现在我给了它一个偏航角（Yaw）和一个俯仰角（Pitch），进行某种旋转后，相机现在看向哪里（即 front 向量）。



计算出新的front向量后，只需要把Camera的基向量和矩阵全部重新算一遍，就能实现相机的视角转动了。（新的数据会在下一轮渲染循环中提交uniform，shader内部再调用GPU进行计算）