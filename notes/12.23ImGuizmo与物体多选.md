# 12.23ImGuizmo与物体多选

ImGuizmo是专为ImGui库开发的一个Gizmo库

## 1.开启ImGuizmo

在开启ImGui帧之后

// 开始 ImGuizmo 帧
ImGuizmo::BeginFrame();

即可。

设置ImGuizmo绘制的大小等：（本项目目前在视口面板调用）

```
ImGuizmo::SetRect(m_ViewportBounds[0].x, m_ViewportBounds[0].y, m_ViewportSize.x, m_ViewportSize.y);

ImGuizmo::SetDrawlist(); // 如果在一个 ImGui 窗口内绘制，确保 ImGuizmo 使用该窗口的绘图列表
```

然后绘制

```
ImGuizmo::SetID(-1);


ImGuizmo::Manipulate(
    glm::value_ptr(ec->GetViewMatrix()),
    glm::value_ptr(ec->GetProjection()),
    m_Context->mCurrentGizmoOperation,
    m_Context->mCurrentGizmoMode,
    glm::value_ptr(ref)
);
```

Manipulate就是绘制的调用，需要传入：

1.相机viewMat

2.相机projMat

3.Gizmo操作模式（平移、旋转、缩放）

4.Gizmo坐标系的模式（世界和局部）

5.监听的物体矩阵ref

绘制就能直接把操作杆绘制在ref的位置上（第四列转vec3就是位置），并且监听 ref ，拖动 gizmo 就能更新ref矩阵

但是由于我们的transform是组件形式，内部保存的是position、rotation、scale，获取矩阵时实时计算，所以获取到的ref不能实时更新transform组件，我们要手动分解矩阵并更新transform组件：

```
// 如果操作了，计算 Delta 并应用到所有物体
if (ImGuizmo::IsUsing()) {
    // 计算变化量： 新 = Delta * 旧  ==>  Delta = 新 * Inverse(旧)
    // 这种方法能同时处理 平移、旋转和缩放
    deltaMatrix = ref * glm::inverse(oldRef);

    for (auto& entity : selectedEntities) {
    auto& transform = entity.GetComponent<TransformComponent>();

    // A. 还原该物体当前的矩阵
    glm::mat4 entityMatrix;
    ImGuizmo::RecomposeMatrixFromComponents(
        glm::value_ptr(transform.position),
        glm::value_ptr(transform.rotation),
        glm::value_ptr(transform.scale),
        glm::value_ptr(entityMatrix)
    );

    // B. 应用变化量
    glm::mat4 newEntityMatrix = deltaMatrix * entityMatrix;

    // C. 分解回组件
    float translation[3], rotation[3], scale[3];
    ImGuizmo::DecomposeMatrixToComponents(
        glm::value_ptr(newEntityMatrix),
        translation,
        rotation,
        scale
    );

    transform.position = glm::make_vec3(translation);
    transform.rotation = glm::make_vec3(rotation);
    transform.scale = glm::make_vec3(scale);
    }
}
```

## 2.关于物体多选

本引擎的多选逻辑是：

面板监听一个selectedEntity实体，用作属性面板的数据展示对象，但是它并非视口层面的被选中；

在整个编辑器或者说视口中，物体的选中与否直接与 “edgeEnable” 属性有关，它是Model组件的一个属性，表示物体是否有选中的边缘线，如果有，物体就被认为是被选中的。

所以，我们目前不维护一个真正的selectedEntities实体列表，在视口的gizmo绘制中：

```
// 收集选中物体并计算中心点
std::vector<Entity> selectedEntities;
glm::vec3 avgPosition = { 0.0f, 0.0f, 0.0f };
int count = 0;
auto modelview = m_Scene->GetAllofEntitiesWith<TransformComponent, ModelComponent>();
for (auto [entity, transform, model] : modelview.each()) {
    if (model.edgeEnable) {
        selectedEntities.push_back({ entity, m_Scene.get() });
        avgPosition += transform.position;
        count++;
    }
}

// 如果没有选中任何物体，直接结束
if (selectedEntities.empty()) {
    ImGui::End();
    ImGui::PopStyleVar();
    return;
}

// 计算中心位置
avgPosition /= (float)count; // 坐标总和除以数量就是中心坐标

// RecomposeMatrixFromComponents 构建 Gizmo 矩阵 ref
glm::mat4 ref;
TransformComponent firstTransform = selectedEntities[0].GetComponent<TransformComponent>();

if (selectedEntities.size() == 1) {
    // 单选模式：完全对齐物体
    ImGuizmo::RecomposeMatrixFromComponents(
    glm::value_ptr(firstTransform.position),
    glm::value_ptr(firstTransform.rotation),
    glm::value_ptr(firstTransform.scale),
    glm::value_ptr(ref)
    );
}
else {
    // 多选模式：位置在中心
    ImGuizmo::RecomposeMatrixFromComponents(
    glm::value_ptr(avgPosition),
    glm::value_ptr(glm::mat4(0.0f)),
    glm::value_ptr(glm::vec3(1.0f)),
    glm::value_ptr(ref)
    );
}
```

我们遍历model.edgeEnable = true的物体，并且计算它们的中心位置，绘制一个唯一的中央gizmo，在操作时，遍历selectedEntities并更新它们的transform组件。