# 11.30相机SetPosition的有趣误区

```
inline void SetPosition(const glm::vec3& deltaPosition) {
	m_Position = m_Position + deltaPosition;
	this->RecalculateMatrix();
}
```

中，参数deltaPosition表示相机位置的变化值，加上原本的坐标就是移动后的位置，之后RecalculateMatrix重新计算矩阵，就能看到对应的结果了。

我的键盘读取代码如下：

```
inline bool OnKeyPressed(Snail::KeyPressEvent& e) {
	switch (e.GetKeyCode()) {
	case (SNL_KEY_W): 
	m_Camera->SetPosition(glm::vec3(0.0f, m_CameraSpeed, 0.0f)); break;
	case (SNL_KEY_A): 
	m_Camera->SetPosition(glm::vec3(-m_CameraSpeed, 0.0f, 0.0f)); break;
	case (SNL_KEY_S): 
	m_Camera->SetPosition(glm::vec3(0.0f, -m_CameraSpeed, 0.0f)); break;
	case (SNL_KEY_D): 
	m_Camera->SetPosition(glm::vec3(m_CameraSpeed, 0.0f, 0.0f)); break;
	}
	return false;
}
```

结果请看视频：

<video src="videos\屏幕录制 2025-11-30 230709.mp4"></video>

奇不奇怪哈哈哈，为什么我每种键值明明只设置了一个轴的变化，结果立方体却开始旋转了？？而且按住不放会跑得越来越远......

这里就要重新回顾一下3D情形下我所使用的矩阵是如何生成的了：





**// 参数: 眼睛位置, 目标位置, 上向量**
**m_ViewMatrix = glm::lookAt(m_Position, m_Front, m_Up);**

**m_ProjectionMatrix = glm::perspective(glm::radians(m_FOV), m_Aspect, m_NearPoint, m_FarPoint);**



请看lookAt参数：m_Position、m_Front、m_Up

恍然大悟，m_Front始终没有改变，一直是最初的原点（0,  0,  0），所以我们的相机始终在盯着原点看，在一个平行于xy平面的平面上**移动+旋转**并且离原点距离越远，旋转速度越慢！

修改：

```
inline void SetPosition(const glm::vec3& deltaPosition) {
	m_Position = m_Position + deltaPosition;
	// !注意! 在xy平面移动时，m_Front仍然是 glm::vec3(0.0f, 0.0f, 0.0f)，
	// 这样并不是平移效果，而是一直盯着原点在移动
	m_Front = m_Front + position;
	this->RecalculateMatrix();
}
```

