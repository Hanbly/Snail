# 11.17预编译头文件 & CPP编译单元的问题

一句话总结：cpp只将.cpp文件进行编译，首先递归读入.h等头文件，整合成一个编译单元后编译，因此.h内部不要求包含其**依赖的环境**（上下文），只要**引用它的**cpp文件包含所有上下文即可。

问题1.为什么客户端项目Example不引用预编译头文件的情况下，我可以通过将spdlog第三方库引用维持在Log中来避免错误，但一旦我把spdlog的引用集成到预编译头文件，则运行失败，为什么这个操作会影响客户端：

```
#include "Snail.h"（等价于：
#pragma once

#include "Snail/Application/Application.h"

#include "Snail/Logger/Log.h"

// 程序入口 -------------------------
#include "Snail/EntryPoint.h"
//----------------------------------）

class Example : public Snail::Application {
public:
Example() {}
~Example() {}

};

Snail::Application* Snail::CreateApplication()
{
return new Example();
}
```

而一旦客户端项目创建相同的预编译头文件并且以上代码加上#include "SNLpch.h"，就能成功生成？

2.Snail/EntryPoint.h如下，没有引入预编译头文件，为什么能够成功编译？明明依赖了windows.h和Log等部分？

```
#pragma once

#ifdef SNL_PLATFORM_WINDOWS

extern Snail::Application* Snail::CreateApplication();

int main(int argc, char** argv)
{
	SetConsoleOutputCP(CP_UTF8);

	Snail::Log::InitLoggers();
	SNL_CORE_TRACE("核心日志初始化!");
	SNL_ERROR("客户端日志初始化错误");

	auto app = Snail::CreateApplication();
	app->run();
	delete app;
}

#endif
```

![Thinking](https://www.gstatic.com/aistudio/watermark/watermark.png)

这两个问题问得非常好，它们直击了C++项目结构、预编译头（PCH）和编译单元（Translation Unit）的核心概念。我来为你详细拆解一下。

------



### 问题1: 为什么将spdlog移入PCH会破坏未配置PCH的客户端？

这是一个关于 **“依赖可见性”** 的经典问题。

#### 状态一：正常工作时（spdlog 在 Log.h 中）

让我们追踪一下编译器在编译 Example 项目时的“思路”：

1. 编译器开始编译 ExampleApp.cpp。

2. ExampleApp.cpp 包含 #include "Snail.h"。

3. Snail.h 包含 #include "Snail/Logger/Log.h"。

4. 编译器打开 Log.h，它看到了：

   ```
   // Log.h
   #pragma once
   #include "Snail/Core.h"
   #include "spdlog/spdlog.h" // <-- 在这里！
   #include <memory>         // <-- 假设也在某个地方被包含了，为了 std::shared_ptr
   
   namespace Snail {
       class Log {
       private:
           // 编译器在这里看到 std::shared_ptr 和 spdlog::logger
           // 它知道这些类型是什么，因为头文件刚刚被包含进来。
           static std::shared_ptr<spdlog::logger> s_CoreLogger; 
       };
   }
   ```

5. **结论**：Log.h 是一个 **“自给自足”** 的头文件。它自己声明了它所需要的所有依赖（spdlog、memory）。所以，任何一个 .cpp 文件只要包含了 Log.h，就自动获得了 spdlog 的所有定义，因此编译可以通过。

#### 状态二：运行失败时（spdlog 移到 SNLpch.h 中）

现在，我们再追踪一次编译器的“思路”：

1. 编译器开始编译 ExampleApp.cpp。

2. ExampleApp.cpp 包含 #include "Snail.h"。

3. Snail.h 包含 #include "Snail/Logger/Log.h"。

4. 编译器打开 Log.h，但现在它看到了：

   ```
   // Log.h
   #pragma once
   #include "Snail/Core.h" 
   // spdlog 和 memory 的 include 已经被移走了！
   
   namespace Snail {
       class Log {
       private:
           // 编译器在这里看到了 std::shared_ptr 和 spdlog::logger
           // 它会问：“什么是 std::shared_ptr? 什么是 spdlog::logger?”
           // 因为 `ExampleApp.cpp` 这个编译单元没有包含 <memory> 和 spdlog 的头文件，
           // 编译器找不到定义，所以它会报错！
           static std::shared_ptr<spdlog::logger> s_CoreLogger; 
       };
   }
   ```

5. **结论**：Log.h 现在变成了一个 **“非自给自足”** 的头文件。它**依赖**于某些外部条件——它假设任何包含它的文件都已经提前包含了 <memory> 和 spdlog 的头文件。

   - 你的 Snail 引擎项目能编译成功，是因为 Snail 项目中的所有 .cpp 文件都配置了使用 SNLpch.h，满足了这个假设。
   - 你的 Example 客户端项目编译失败，是因为它没有配置使用 SNLpch.h，没有满足这个假设，所以编译器在解析 Log.h 时就“懵了”。

#### 为什么加上 #include "SNLpch.h" 并配置PCH就能成功？

当你这么做之后，编译 ExampleApp.cpp 的流程变成了：

1. 编译器开始编译 ExampleApp.cpp。

2. 因为配置了PCH，编译器**首先**会加载预编译好的 SNLpch.h 的内容。现在，std::shared_ptr 和 spdlog 的所有定义都已经被加载到编译器的“内存”中了。

3. 然后编译器处理 ExampleApp.cpp 的第一行：#include "SNLpch.h" (它会跳过，因为已经处理过了)。

4. 接着处理 #include "Snail.h"，然后是 #include "Snail/Logger/Log.h"。

5. 当编译器再次看到 Log.h 中的 std::shared_ptr<spdlog::logger> 时，它会说：“哦，我认识你们！我刚刚在 SNLpch.h 里见过你们的定义。”

6. 编译顺利通过。

   

   ---------Snail.h _ 由Example项目的ExampleApp.cpp引用---------------

   ```c++
   #pragma once
   
   #include "Snail/Application/Application.h"
   
   #include "Snail/Logger/Log.h"
   
   // 程序入口 -------------------------
   #include "Snail/EntryPoint.h"
   //----------------------------------
   ```

   其中Snail/EntryPoint.h使用Snail/Logger/Log.h的宏，

- **原来**：Snail/Logger/Log.h本身引用第三方库文件，自给自足，Snail/EntryPoint.h认识宏；
- **后来**：Snail/Logger/Log.h本身不含有第三方库文件，而是整合到预编译头文件，只有Snail/Logger/Log.cpp等Snail项目的**编译单元**（.cpp)引用，而处在Example项目的ExampleApp.cpp引用时，并没有对应的第三方库文件被引入进来！

------



### 问题2: 为什么 EntryPoint.h 没有引入PCH也能成功编译？

这是一个关于 **“编译单元（Translation Unit）”** 的核心概念。

**最重要的原则：头文件（.h, .hpp）本身是不会被“编译”的。真正被编译的是源文件（.cpp）。**

当编译器编译一个 .cpp 文件时，它会执行以下操作：

1. 预处理器首先将该 .cpp 文件中所有 #include 的头文件内容，递归地展开并粘贴到 .cpp 文件中。
2. 最终形成一个巨大的、临时的“虚拟”源文件。这个文件被称为一个 **“编译单元” (Translation Unit)**。
3. 编译器只编译这个最终的编译单元。

现在我们来看 EntryPoint.h：

- EntryPoint.h 这个文件本身孤零零地放在那里，什么都不会发生。
- 它的代码**真正生效**的地方，是在它被包含进的那个 .cpp 文件里。在你的项目中，这个 .cpp 文件就是 ExampleApp.cpp。

让我们追踪一下 ExampleApp.cpp 这个编译单元最终的样子（简化版）：

```
// 这是编译器最终“看到”的 ExampleApp.cpp 编译单元

// === 1. 来自 SNLpch.h (因为配置了PCH并include) ===
#include <windows.h> // 提供了 SetConsoleOutputCP
#include "Snail/Logger/Log.h" // 提供了 Log类, SNL_CORE_TRACE, SNL_ERROR宏
// ... SNLpch.h 里的其他所有内容

// === 2. 来自 ExampleApp.cpp 自身 ===
#include "Snail.h" // 这个会被展开

// === 3. 来自 Snail.h 的展开 ===
// #pragma once
// #include "Snail/Application/Application.h"
// #include "Snail/Logger/Log.h" // (因为有#pragma once，这里会被忽略)
// #include "Snail/EntryPoint.h" // <-- 现在轮到它了

// === 4. 来自 EntryPoint.h 的展开 ===
#pragma once
#ifdef SNL_PLATFORM_WINDOWS
    extern Snail::Application* Snail::CreateApplication();
    int main(int argc, char** argv)
    {
        // 当编译器读到这里时，windows.h 和 Log.h 的内容
        // 在这个编译单元的“上方”早就已经存在了！
        SetConsoleOutputCP(CP_UTF8); 
        Snail::Log::InitLoggers();
        SNL_CORE_TRACE("核心日志初始化!");
        // ...
    }
#endif
// ... ExampleApp.cpp 中剩余的代码 ...
```

**结论：**
EntryPoint.h 不需要自己 #include "SNLpch.h"，因为它被设计为在一个**已经包含了所有必要依赖的环境**中被使用。

在你的项目中，ExampleApp.cpp 创建了这个环境：它通过 #include "SNLpch.h" 准备好了 windows.h 和 Log.h 等所有东西，然后才通过 #include "Snail.h" 间接地把 EntryPoint.h 的代码“请”了进来。到 EntryPoint.h 的代码出场时，所有舞台道具（依赖项）都已准备就绪。

所以，不是 EntryPoint.h 能够“神奇地”编译，而是包含它的 ExampleApp.cpp 为它提供了所有必要的编译上下文。