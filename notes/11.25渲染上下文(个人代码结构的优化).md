# 11.25渲染上下文(个人:代码结构的优化)

cherno所介绍过**Renderer与RenderAPI**两者的关系，Renderer是不关心api/平台类型的渲染器，而RendererAPI是每个api/平台的具体渲染流程接口，Renderer可以在内部调用不同的RendererAPI从而实现让**Renderer**简单地被创建使用，使用方不关心具体实现。

我也说不上是不是一种优化，大概是：使用新的**Renderer类**包装**RenderAPI**中的内容，包括**RenderContext**类，也包括**以后将创建的类**，但是Renderer不再是一种抽象类或基类，从而在派生类实现不同的代码，而是在需要的方法中接收对应api或平台的枚举类型作为参数，再在内部分支依据不同的枚举类型调用不同的RenderAPI。

这样做的根本性变动其实并不是使用 Renderer 就比 RenderContext 方便多少，而是通过一层包装，把 **RenderAPI** 的调用从**WindowsWindow** 中剥离出去，移放到Renderer内部，这样

①WindowsWindow 不再依赖 RenderContext 的派生类，只依赖Renderer，比如之前需要引入OpenGLRenderContext 类，现在只依赖Renderer，能简化WindowsWindow的复杂度（其实复杂度被转移到Renderer了）。

![屏幕截图 2025-11-25 190839](images\屏幕截图 2025-11-25 190839.png)

如图是我目前的文件结构，目前的项目分为**Snail和 Platform**，理想情况下Snail存放**抽象内容、通用内容**；而Platform存放**特定的编码**，要么是特定窗口库（glfw）,特定api（opengl），要么是特定平台（windows）。

WindowsWindow既包含glfw依赖，又在**含义上**依赖Windows平台，其实并非最细粒度的依赖（同时依赖glfw和windows），而我不想让它既依赖GLFW又依赖Windows。

（为什么说是**“含义上”**？因为WindowsWindow本身就是Window类的派生类，当时抽象Window类的时候意图就是把不同的操作系统/平台的Window实现区分开来，这也是WindowsWindow命名的来源；但现在实际上并没有Windows特异性代码）

目前考虑的解决方法是：暂时维持，当以后需要其他窗口库（sdl等）的时候再重写实现，现在暂且把glfw当作一个泛用的依赖，不分离它。