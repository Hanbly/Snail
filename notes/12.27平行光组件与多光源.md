# 12.27平行光组件与多光源

## 一、平行光与点光源

之前本引擎实现的是点光源，即一个有实际位置的灯泡;

在物体的片段着色器中，我们接收**具体的光源位置**、颜色、强度等信息，然后依据法线 a_Normal + 法线矩阵 normalMatrix，所组成的片段的法线信息

```
v_Normal = normalize(normalMatrix * a_Normal); 
```

而法线v_Normal与光照方向lightDir之间的**点积**表示夹角能一定程度上影响漫反射光照diffuse的强度；

我们还接收相机的位置信息，用于计算观察方向（相机 - 片段）

```
vec3 viewDir = normalize(u_ViewPosition - v_FragPos);
```

而 viewDir 和 反射光线方向 reflectDir 之间的**点积**就能反映镜面反射的强度。



以上光照模型是基于Phong经验模型的，我们额外添加了平行光和点光源的衰减系数：

平行光的计算与点光源完全一样，只不过它没有实际的位置，在使用 lightDir 不需要额外计算了；

点光源的衰减遵循
$$
Fatt=\frac{1.0}{Kc+Kl∗d+Kq∗d^2}
$$
c、d、q分别对应衰减系数constant、linear、quadratic；d则表示光源的距离。

所以实现就是计算衰减量attenuation：

```
float distance = length(light.position - fragPos);
float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
```

## 二、多光源

在之前，我们的Scene.cpp只会寻找第一个点光源，然后用Renderer3D绘制，现在我们要支持多光源，所以就要扩展整个Renderer3D，让它能接收一个光源列表：

```
std::vector<DirectionLight> dirLights;
std::vector<PointLight> poiLights;

// --- 平行光源组件 ---
{
	auto view = m_Registry.view<DirectionalLightComponent>();
	for (auto [entity, light] : view.each())
	{
		glm::vec3 lightDir = light.direction;
		glm::vec4 lightColor = light.color;
		float ambient = light.ambient;
		float diffuse = light.diffuse;
		float specular = light.specular;
		DirectionLight directionLight(lightDir, lightColor, ambient, diffuse, specular);

		dirLights.push_back(directionLight);
	}
}

// --- 点光源组件 ---
{
    auto view = m_Registry.view<TransformComponent, PointLightComponent>();
    for (auto [entity, transform, light] : view.each())
    {
        glm::vec3 lightPos = transform.position;
        glm::vec4 lightColor = light.color;
		float constant = light.constant;
		float linear = light.linear;
		float quadratic = light.quadratic;
		float ambient = light.ambient;
		float diffuse = light.diffuse;
		float specular = light.specular;
        PointLight pointLight(lightPos, lightColor, constant, linear, quadratic, ambient, diffuse, specular);
        
        poiLights.push_back(pointLight);
    }
}

Renderer3D::BeginScene(camera.get(), cameraTransform, dirLights, poiLights);
...其它步骤
```

在BeginScene中，我们其实就是简单的复制两种光源列表的数据，然后我们有一个上传数据的函数：

```
void Renderer3D::UploadLightsUniforms(const Refptr<Shader>& shader)
{
	// --- 上传平行光 ---
	int dirLightIndex = 0;
	for (auto& dl : s_3DSceneData.DirLights) {
		// 限制最大光源数量，防止越界（需与 Shader 中的 #define 保持一致）
		if (dirLightIndex >= 4) break;

		std::string baseName = "u_DirLights[" + std::to_string(dirLightIndex) + "]";

		shader->SetFloat3(baseName + ".direction", dl.direction);
		shader->SetFloat3(baseName + ".color", dl.color);
		shader->SetFloat(baseName + ".ambient", dl.ambient);
		shader->SetFloat(baseName + ".diffuse", dl.diffuse);
		shader->SetFloat(baseName + ".specular", dl.specular);

		dirLightIndex++;
	}
	// 告诉 Shader 实际有多少个平行光
	shader->SetInt("u_DirLightCount", dirLightIndex);

	// --- 上传点光源 ---
	int pointLightIndex = 0;
	for (auto& pl : s_3DSceneData.PoiLights) {
		if (pointLightIndex >= 16) break; // Shader 中最大定义为 16

		std::string baseName = "u_PointLights[" + std::to_string(pointLightIndex) + "]";

		shader->SetFloat3(baseName + ".position", pl.position);
		shader->SetFloat3(baseName + ".color", pl.color);
		shader->SetFloat(baseName + ".constant", pl.constant);
		shader->SetFloat(baseName + ".linear", pl.linear);
		shader->SetFloat(baseName + ".quadratic", pl.quadratic);
		shader->SetFloat(baseName + ".ambient", pl.ambient);
		shader->SetFloat(baseName + ".diffuse", pl.diffuse);
		shader->SetFloat(baseName + ".specular", pl.specular);

		pointLightIndex++;
	}
	// 告诉 Shader 实际有多少个点光源
	shader->SetInt("u_PointLightCount", pointLightIndex);
}
```

可以看到，我们是在与shader中的两个结构体对应，并且上传所有光照的uniforms数组：（shader）

```
struct DirLight {
    vec3 direction;
    vec3 color;
    float ambient;
    float diffuse;
    float specular;
};

struct PointLight {
    vec3 position;
    vec3 color;
    float constant;
    float linear;
    float quadratic;
    float ambient;
    float diffuse;
    float specular;
};

uniform DirLight u_DirLights[MAX_DIR_LIGHTS];
uniform int u_DirLightCount;

uniform PointLight u_PointLights[MAX_POINT_LIGHTS];
uniform int u_PointLightCount;
```

于是在片段着色器中，我们加一个循环即可，把光照计算抽象一个函数，并遍历两个uniforms数组对应平行光和点光源

```
// 计算平行光
int dirCount = min(u_DirLightCount, 4);
for(int i = 0; i < dirCount; i++)
{
    vec3 lightDir = normalize(-u_DirLights[i].direction);
    
    float shadow = 0.0;
    
    if(i == 0) {
        shadow = ShadowCalculation(v_FragPosLightSpace, norm, lightDir);
    }
    
    result += CalcDirLight(u_DirLights[i], norm, viewDir, diffMapColor, specMask, shadow);
}

// 计算点光源
int pointCount = min(u_PointLightCount, 16);
for(int i = 0; i < pointCount; i++)
{
    result += CalcPointLight(u_PointLights[i], norm, v_FragPos, viewDir, diffMapColor, specMask);
}

result = result / (result + vec3(1.0));

FinalColor = vec4(result, 1.0);
```

