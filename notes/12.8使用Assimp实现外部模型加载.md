# 12.8使用Assimp实现外部模型加载

## 一、实现Mesh类

mesh，即网格，mesh类代表的是最小渲染单元，比如之前我渲染出的立方体，其实就可以算作一个mesh；而对于我们接下来要处理的外部模型Model，mesh就是整个物体的一小部分，例如一个汽车模型，它的方向盘就是一个mesh，一只轮胎也是一个mesh...

所以mesh可以看作是外部模型model的组成部分。

#### 1.Mesh类的组成

Mesh类持有 VAO 、材质 Material 和 一个表示Mesh相对于模型整体的转换矩阵 LocalTransform 。

###### 介绍材质 Material 

这是我之前创建的类，在笔记中没有提及到过，简单介绍它，就是Shader、Uniforms 和 Texture 的集合体。

一个material对象持有一个shader成员，各种类型 uniform 变量的缓存（映射表），和纹理的缓存表，例如：

std::unordered_map<std::string, int> m_Ints; 表示int类型的uniform，其中**map的Key**对应**shader**中静态编译的uniform名称；

std::unordered_map<std::string, Refptr\<Texture\>> m_Textures; 则保存材质所有的纹理对象的引用；

关键点是material的Bind方法：

```
void Material::Bind() const
{
	m_Shader->Bind();

	// 上传所有缓存的 Uniform 数据
	for (const auto& [name, value] : m_Ints) m_Shader->SetInt(name, value);
	for (const auto& [name, value] : m_Floats) m_Shader->SetFloat(name, value);
	for (const auto& [name, value] : m_Float3s) m_Shader->SetFloat3(name, value);
	for (const auto& [name, value] : m_Float4s) m_Shader->SetFloat4(name, value);
	for (const auto& [name, value] : m_Mat3s) m_Shader->SetMat3(name, value);
	for (const auto& [name, value] : m_Mat4s) m_Shader->SetMat4(name, value);

	// 绑定纹理
	int slot = 0;
	for (const auto& [name, texture] : m_Textures)
	{
		texture->Bind(slot);
		m_Shader->SetInt(name, slot);
		slot++;
	}
}
```

它可以全自动地上传所有缓存的uniform变量和texture对象，只需要先将uniform缓存到材质，调用该方法就可以上传所有uniform；在实际渲染前调用该方法，就能简洁地更新所有参数变化。

#### 2.Mesh类的关键方法

Mesh类的结构很简单，①构建Mesh；②绘制Mesh。

##### ①构建Mesh

这一部分是重点。Mesh包含的部分有VAO、材质 Material 和 一个表示Mesh相对于模型整体的转换矩阵 LocalTransform 。

VAO的创建不难，就是我们之前写在Example层的顶点信息，所以这也决定了Mesh构造方法需要两个数据参数 vertices和indices；而 material 含有shader和多个textures，所以构造方法还要接收一个 shader，一个 textures列表，值得注意的是在构造 material 时我们要组装一个TextureData结构体。

###### TextureData结构体

> 这个东西简单说就是含有一个texture对象引用、一个类型type、一个文件名称path的数据体。其中type其实对应了 material 中映射表的第一个字段，我们不希望这个映射表保存类似于{"texture\_轮胎", texture1}、{"texture\_车灯", texture2}这种数据，因为每个模型所含有的部分是不一样的，所以最好是保存一些更通用的类型，而不是具体的名称。

###### texture的类型

> 目前可以简单分为 漫反射纹理 和 镜面反射纹理。漫反射纹理表示的就是直观理解中物体表面的贴图，它描述物体应该是什么颜色，什么样子；镜面反射纹理表示的是物体的镜面反射属性，这跟光照部分有点相关，也就是说物体的哪些部位应该有镜面反射，或者说一个部分应该有多强的镜面反射。总之，就是 texture_diffuse 和 texture_specular 两种类型。

回到构建方法，现在我们知道了如何创建材质 material，当接收到一个纹理列表后，我们检测纹理的类型，并且累加同种类纹理的数量，构造一系列"u_Diffuse1""u_Diffuse2""u_Diffuse3"...列表，之后传入shader和刚才的列表用以构造一个材质 material。

##### ②绘制Mesh

绘制Mesh与我们之前使用Renderer3D绘制的方法是一样的，但是在绘制之前，需要考虑Mesh的转换，因为Mesh是整个模型的一部分，模型并不是一体绘制的，mesh作为一部分，也就有不同的相对位置。

所以这个方法我们除了照常接收一个世界坐标系的物体转换矩阵 worldTransform 还有一个局部转换矩阵 LocalTransform，这个矩阵来自于我们之后加载的model数据，也可以不设置，所以默认为单位矩阵。

## 二、实现Model类

如果说 Mesh 是肌肉和皮肤，那么 Model 就是骨架和整体的控制中心。Model 类对应的正是 Assimp 中的 `aiScene` 或者说整个模型文件。它的主要职责是：**读取文件、递归解析节点树、转换数据格式，最终生成一组 Mesh。**

#### 1. 引入 Assimp 

我们不需要自己去写复杂的 .obj 或 .fbx 解析器，Assimp 库帮我们完成了这项繁重的工作。它将各种不同格式的模型文件统一解析为一种树状结构：

- **aiScene**: 根节点，包含所有的网格、材质、纹理等数据。
- **aiNode**: 场景中的节点，包含转换矩阵和子节点，形成了模型的层级结构。
- **aiMesh**: 具体的网格数据（顶点、法线、UV、面索引）。

#### 2. Model类的核心逻辑：递归解析

Model 的加载过程是一个标准的递归过程，核心包含三个方法：`Load`、`ProcessNode` 和 `ProcessMesh`。

**① Load(path) - 入口** 首先使用 `Assimp::Importer` 读取文件。这里有一个关键点：我们需要传入 `aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_GenNormals` 等标志位。

- `Triangulate`: 确保所有的面都被转换为三角形（OpenGL 喜欢三角形）。
- `GenNormals`: 如果模型文件中（如某些简陋的 obj）没有法线数据，Assimp 会自动帮我们计算，**避免了因为法线缺失导致的渲染崩溃**。
- `FlipUVs`: OpenGL 的纹理坐标原点在左下角，而大多数模型格式在左上角，必须翻转 y 轴。

**② ProcessNode - 遍历节点树** 这是处理父子层级关系的地方。Assimp 的节点树中，每个节点都有一个相对于父节点的变换矩阵。为了得到每个 Mesh 在世界空间（或者说模型空间）的正确位置，我们需要将父节点的变换矩阵传递给子节点。 代码逻辑如下：

```
void Model::ProcessNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransformation)
{
    // 1. 获取当前节点的变换矩阵，并与父级矩阵相乘
    glm::mat4 currentTransform = parentTransformation * ConvertaiMat4ToglmMat4(node->mTransformation);

    // 2. 处理当前节点下的所有 Mesh
    for (uint32_t i = 0; i < node->mNumMeshes; i++)
    {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        // 将累积的变换矩阵传给 Mesh，这就是 Mesh 中的 m_LocalTransform
        m_Meshs.push_back(ProcessMesh(mesh, scene, currentTransform));
    }

    // 3. 递归处理子节点
    for (uint32_t i = 0; i < node->mNumChildren; i++)
    {
        ProcessNode(node->mChildren[i], scene, currentTransform);
    }
}
```

**③ ProcessMesh - 数据转换** 这一步是核心流程，我们先调用

aiMesh* mesh->mNumVertices 获取模型的顶点数据，然后赋值转换到我们自己的vertex数据结构中，分别包含mesh->mVertices、mesh->mNormals、mesh->mTextureCoords，最终生成vertices数据；

aiMesh* mesh->mNumFaces 获取模型的索引数据，然后一样赋值到我们自己的数组中，最后生成indices数据；

aiMesh* mesh->mMaterialIndex 用来表示模型的材质，aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex] 可以获取模型的材质数据，之后依据纹理类型（漫反射或镜面反射纹理），分别用我们自己的 LoadMaterialTextures 检索Assimp给的 material 数据，并加载其中可能存在的纹理到我们自己的材质中。

```
if (mesh->mMaterialIndex >= 0)
{
	aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];

	std::vector<TextureData> diffuseMaps = LoadMaterialTextures(material, aiTextureType_DIFFUSE, "texture_diffuse");
	textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());

	std::vector<TextureData> specularMaps = LoadMaterialTextures(material, aiTextureType_SPECULAR, "texture_specular");
	textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());
}
```

之后值得注意的是没有纹理的情况，常见的例子就是obj文件和mtl文件的组合，但是没有textures资源，这种模型其实就是纯色模型，颜色信息和反光度等信息大量大量定义在mtl文件中，我们使用Assimp提供的方法检索这些信息，读取 `.mtl` 文件中定义的**固有颜色参数**，并注入到提前构造的 resultMesh 的材质中：

（resultMesh 在 顶点数据&索引数据&可能的材质数据 获取之后构造，而下面的数据不作为Mesh的构建参数，只是uniform变量，所以正好提前构建一个Mesh，然后通过它进行uniform的设置）（这里通过Shader注入uniform也是一样的）

- **漫反射颜色 (Kd -> u_ColorDiffuse)**: 模型的底色。
- **镜面颜色 (Ks -> u_ColorSpecular)**: 高光的颜色。
- **环境光颜色 (Ka -> u_ColorAmbient)**: 阴影处的颜色。
- **光泽度 (Ns -> u_Shininess)**: 决定高光点的聚焦程度。

```
Refptr<Mesh> resultMesh = std::make_shared<Mesh>(vertices, indices, m_Shader, textures, localTransformation);

// 处理材质（颜色）
if (mesh->mMaterialIndex >= 0)
{
	aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];

	// 1. 读取漫反射颜色 (Diffuse Color / Kd)
	aiColor3D diffuseColor(0.8f, 0.8f, 0.8f); // 默认灰色
	if (material->Get(AI_MATKEY_COLOR_DIFFUSE, diffuseColor) == AI_SUCCESS)
	{
		// 将读取到的颜色传给材质
		resultMesh->GetMaterial()->SetFloat3("u_ColorDiffuse", glm::vec3(diffuseColor.r, diffuseColor.g, diffuseColor.b));
	}

	// 2. 读取镜面光颜色 (Specular Color / Ks)
	aiColor3D specularColor(0.5f, 0.5f, 0.5f);
	if (material->Get(AI_MATKEY_COLOR_SPECULAR, specularColor) == AI_SUCCESS)
	{
		resultMesh->GetMaterial()->SetFloat3("u_ColorSpecular", glm::vec3(specularColor.r, specularColor.g, specularColor.b));
	}

	// 3. 读取环境光颜色 (Ambient Color / Ka)
	aiColor3D ambientColor(0.1f, 0.1f, 0.1f);
	if (material->Get(AI_MATKEY_COLOR_AMBIENT, ambientColor) == AI_SUCCESS)
	{
		resultMesh->GetMaterial()->SetFloat3("u_ColorAmbient", glm::vec3(ambientColor.r, ambientColor.g, ambientColor.b));
	}

	// 4. 读取光泽度 (Shininess / Ns)
	float shininess = 32.0f;
	if (material->Get(AI_MATKEY_SHININESS, shininess) == AI_SUCCESS)
	{
		resultMesh->GetMaterial()->SetFloat("u_Shininess", shininess);
	}
}
return resultMesh;
```

#### 3. 纹理加载与缓存（LoadMaterialTextures 方法 和 m_LoadedTextures 缓存）

**为什么需要缓存？**

一个模型（比如 Sponza 场景）中，多个 Mesh 可能会共用同一张纹理（例如地板和墙壁可能用同一张砖块图）。如果每个 Mesh 都重新加载一次图片（纹理），显存会瞬间爆炸。 因此，我们在 Model 类中维护了一个 `m_LoadedTextures` 列表。在 `LoadMaterialTextures` 时：

1. 首先通过Assimp获取模型资源自己保存的纹理路径，再检查纹理路径是否已存在于 `m_LoadedTextures` 中。
2. 如果存在，直接复用该 Texture 指针，把它push到最终的纹理数据之中。
3. 如果不存在，调用 `Texture2D::Create` 加载，并存入m_LoadedTextures缓存。

```
std::vector<TextureData> textures;

for (uint32_t i = 0; i < mat->GetTextureCount(type); i++)
{
	aiString str;
	// 检查 Assimp 是否成功获取了路径
	if (mat->GetTexture(type, i, &str) != AI_SUCCESS) {
		SNL_CORE_WARN("Model: Assimp Failed to get texture path for type {0}, index {1}", typeName, i);
		continue;
	}
	// 防御空路径
	if (str.length == 0) {
		SNL_CORE_WARN("Model: Texture path is empty!");
		continue;
	}

	bool cacheFlag = false; // 将标志位定义移到这里，每次循环重置

	for (uint32_t j = 0; j < m_LoadedTextures.size(); j++) {
		if (std::strcmp(m_LoadedTextures[j].path.data(), str.C_Str()) == 0) {
			textures.push_back(m_LoadedTextures[j]);
			cacheFlag = true;
			break;
		}
	}

	if (!cacheFlag)	{
		TextureData texture;
		// 确保路径拼接逻辑正确
		std::string filename = std::string(str.C_Str());
		std::replace(filename.begin(), filename.end(), '\\', '/');
		std::string fullPath = m_Directory + '/' + filename;

		SNL_CORE_TRACE("Model: 加载纹理路径: '{0}' 中...", fullPath);

		texture.texture = Texture2D::Create(fullPath);
		texture.type = typeName;
		texture.path = filename; // 保存相对路径或文件名用于缓存对比

		textures.push_back(texture);
		m_LoadedTextures.push_back(texture); // 添加到已加载缓存
	}
}
return textures;
```

#### 4.理解谬误

我的shader:

```
#type vertex
#version 330 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 TextureCoords;

out vec2 v_TextureCoords;
out vec3 v_Normal;
out vec3 v_FragPos;

uniform mat4 u_Model;
uniform mat4 u_ViewProjection;
uniform mat3 u_NormalMatrix;

void main()
{
    gl_Position = u_ViewProjection * u_Model * vec4(position, 1.0);
    v_TextureCoords = TextureCoords;
    v_Normal = normalize(u_NormalMatrix * a_Normal);
    v_FragPos = vec3(u_Model * vec4(position, 1.0));
}

#type fragment
#version 330 core

out vec4 FinalColor;

in vec2 v_TextureCoords;
in vec3 v_Normal;
in vec3 v_FragPos;

uniform vec4 u_LightColor;
uniform sampler2D u_Diffuse1;
uniform sampler2D u_Specular1;
uniform bool u_UseTexture;
uniform vec3 u_LightPosition;
uniform vec3 u_ViewPosition;

uniform float u_AmbientStrength;     // 环境光照系数
uniform float u_DiffuseStrength;     // 漫反射系数
uniform float u_SpecularStrength;    // 镜面反射系数

// MTL 的颜色变量
uniform vec3 u_ColorDiffuse;  // Kd
uniform vec3 u_ColorSpecular; // Ks
uniform vec3 u_ColorAmbient;  // Ka
uniform float u_Shininess;    // Ns

void main()
{
    // 1. 获取基础颜色 (有纹理用纹理，没纹理用 Kd)
    vec4 objectColor;
    if(u_UseTexture)
        objectColor = texture(u_Diffuse1, v_TextureCoords);
    else
        objectColor = vec4(u_ColorDiffuse, 1.0);

    if(objectColor.a < 0.1)
        discard;




    // 2. 环境光 (Ambient = Ka * LightColor)
    vec3 ambient = u_ColorAmbient * u_LightColor.rgb * vec3(u_AmbientStrength);

    // 3. 漫反射 (Diffuse = Diff * LightColor)
    vec3 norm = normalize(v_Normal);
    vec3 lightDir = normalize(u_LightPosition - v_FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * u_LightColor.rgb * vec3(u_DiffuseStrength);

    // 4. 镜面反射 (Specular = Spec * Ks * LightColor)
    vec3 viewDir = normalize(u_ViewPosition - v_FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_Shininess);
    
    float specMask = 1.0; // 默认全反光
    if (u_UseTexture) {
        // 从纹理采样。因为高光图通常是黑白的，取红色通道 r 即可
        // 这决定了“哪里该亮，哪里不该亮”
        specMask = texture(u_Specular1, v_TextureCoords).r;
    }
    // 原始高光 * 材质高光色(Ks) * 光源颜色 * 全局强度系数 * 贴图遮罩(specMask)
    vec3 specular = spec * u_ColorSpecular * u_LightColor.rgb * vec3(u_SpecularStrength) * specMask;




    // 5. 组合结果
    // (环境光 + 漫反射) * 物体颜色 + 镜面高光
    vec3 result = (ambient + diffuse + specular) * objectColor.rgb;

    FinalColor = vec4(result, 1.0);
}
```

可以看到对于纹理部分，我只定义了一个u_Diffuse1，这是为什么呢？一个模型难道不应该有大量的图片纹理资源吗？shader难道不应该对应地设置 u_Diffuse1、u_Diffuse2...吗？否则按说没有定义的uniform就会被直接忽略掉。

其实这是个误区，模型往往分为若干个Mesh，而一个Mesh往往只包含一个纹理，或是一个漫反射纹理一个镜面反射纹理，Mesh并不会包含很多很多的纹理，所以实际上的情况是，一个Mesh加载一个 u_Diffuse1，第二个Mesh又加载了另一个 u_Diffuse1，而shader逐个逐个地处理Mesh的，也就是说各个纹理分居不同的Mesh，共享同一个纹理插槽而逐个绘制。

目前的代码在遇到单Mesh多个同类型纹理的情况下，会出错误。





总之，搞了一天终于实现了模型载入，看看效果吧。



<video src="videos\屏幕录制 2025-12-08 232143.mp4"></video>