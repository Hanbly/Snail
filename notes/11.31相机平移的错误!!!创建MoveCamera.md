# 11.31相机平移的错误!!!创建MoveCamera

之前几次笔记中提到我创建了相机移动的简单逻辑，但实际上它们是完全错误的

例如

inline void SetPosition(const glm::vec3& deltaPosition) {
	m_Position = m_Position + deltaPosition;
	// !注意! 在xy平面移动时，m_Front仍然是 glm::vec3(0.0f, 0.0f, 0.0f)，
	// 这样并不是平移效果，而是一直盯着原点在移动
	m_Front = m_Front + position;
	this->RecalculateMatrix();
}

然后在按下wasd时，我对应移动

if (Snail::Input::IsKeyPressed(SNL_KEY_W)) {
	m_Camera->SetPosition(glm::vec3(0.0f, m_CameraMoveSpeed, 0.0f));
}
else if (Snail::Input::IsKeyPressed(SNL_KEY_S)) {
	m_Camera->SetPosition(glm::vec3(0.0f, -m_CameraMoveSpeed, 0.0f));
}
if (Snail::Input::IsKeyPressed(SNL_KEY_A)) {
	m_Camera->SetPosition(glm::vec3(-m_CameraMoveSpeed, 0.0f, 0.0f));
}
else if (Snail::Input::IsKeyPressed(SNL_KEY_D)) {
	m_Camera->SetPosition(glm::vec3(m_CameraMoveSpeed, 0.0f, 0.0f));
}

这显然是错误的！因为SetPosition此时的参数接受的是世界坐标系的一个向量，而实际的相机移动应该按照**其自身的坐标轴**移动，所以我修改了整个SetPosition方法。

```
void Camera::MoveCamera(const TranslationDirection& dir, const float& length) {
		//SNL_TRACE("ExampleLayer 调用: OnUpdate()");
		glm::vec3 frontdDir = glm::normalize(m_Front - m_Position);
		glm::vec3 rightDir = glm::normalize(glm::cross(frontdDir, m_Up));
		glm::vec3 upDir = glm::normalize(glm::cross(rightDir, frontdDir));

		glm::vec3 vector = glm::vec3(0.0f);
		if (dir == TranslationDirection::FRONT) {
			vector = frontdDir * length;
		}
		else if (dir == TranslationDirection::BACK) {
			vector = -frontdDir * length;
		}
		if (dir == TranslationDirection::RIGHT) {
			vector = rightDir * length;
		}
		else if (dir == TranslationDirection::LEFT) {
			vector = -rightDir * length;
		}
		if (dir == TranslationDirection::UP) {
			vector = upDir * length;
		}
		else if (dir == TranslationDirection::DOWN) {
			vector = -upDir * length;
		}

		m_Position = m_Position + vector;
		// !注意! 在xy平面移动时，m_Front仍然是 glm::vec3(0.0f, 0.0f, 0.0f)，
		// 这样看到的并不是平移效果，而是一直盯着原点在移动
		m_Front = m_Front + vector;
		this->RecalculateMatrix();
	}

```

先利用向量的叉积计算出相机坐标系的三个基向量（z轴/x轴/y轴      前轴/右轴/上轴）：

glm::vec3 frontdDir = glm::normalize(m_Front - m_Position);
glm::vec3 rightDir = glm::normalize(glm::cross(frontdDir, m_Up));
glm::vec3 upDir = glm::normalize(glm::cross(rightDir, frontdDir));

> 注意：叉积的顺序决定结果的方向，叉积遵从右手坐标系：食指向前指、中指曲折90°、大拇指向外展开，此时食指是向量a，中指是向量b，大拇指就是叉积结果 aXb。

这样算出来的方向，就可以计算实际的平移向量了，只需要乘以距离（速度）即可

也就是**vector = frontdDir * length;**等语句，vector作为偏移向量与相机原点m_Position相加，最终结果就是移动后的相机位置！